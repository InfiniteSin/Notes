/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/svg-pan-zoom/src/uniwheel.js
var require_uniwheel = __commonJS({
  "node_modules/svg-pan-zoom/src/uniwheel.js"(exports, module2) {
    module2.exports = function() {
      var prefix = "", _addEventListener, _removeEventListener, support, fns = [];
      var passiveOption = { passive: true };
      if (window.addEventListener) {
        _addEventListener = "addEventListener";
        _removeEventListener = "removeEventListener";
      } else {
        _addEventListener = "attachEvent";
        _removeEventListener = "detachEvent";
        prefix = "on";
      }
      support = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
      function createCallback(element, callback) {
        var fn = function(originalEvent) {
          !originalEvent && (originalEvent = window.event);
          var event = {
            originalEvent,
            target: originalEvent.target || originalEvent.srcElement,
            type: "wheel",
            deltaMode: originalEvent.type == "MozMousePixelScroll" ? 0 : 1,
            deltaX: 0,
            delatZ: 0,
            preventDefault: function() {
              originalEvent.preventDefault ? originalEvent.preventDefault() : originalEvent.returnValue = false;
            }
          };
          if (support == "mousewheel") {
            event.deltaY = -1 / 40 * originalEvent.wheelDelta;
            originalEvent.wheelDeltaX && (event.deltaX = -1 / 40 * originalEvent.wheelDeltaX);
          } else {
            event.deltaY = originalEvent.detail;
          }
          return callback(event);
        };
        fns.push({
          element,
          fn
        });
        return fn;
      }
      function getCallback(element) {
        for (var i = 0; i < fns.length; i++) {
          if (fns[i].element === element) {
            return fns[i].fn;
          }
        }
        return function() {
        };
      }
      function removeCallback(element) {
        for (var i = 0; i < fns.length; i++) {
          if (fns[i].element === element) {
            return fns.splice(i, 1);
          }
        }
      }
      function _addWheelListener(elem, eventName, callback, isPassiveListener) {
        var cb;
        if (support === "wheel") {
          cb = callback;
        } else {
          cb = createCallback(elem, callback);
        }
        elem[_addEventListener](prefix + eventName, cb, isPassiveListener ? passiveOption : false);
      }
      function _removeWheelListener(elem, eventName, callback, isPassiveListener) {
        var cb;
        if (support === "wheel") {
          cb = callback;
        } else {
          cb = getCallback(elem);
        }
        elem[_removeEventListener](prefix + eventName, cb, isPassiveListener ? passiveOption : false);
        removeCallback(elem);
      }
      function addWheelListener(elem, callback, isPassiveListener) {
        _addWheelListener(elem, support, callback, isPassiveListener);
        if (support == "DOMMouseScroll") {
          _addWheelListener(elem, "MozMousePixelScroll", callback, isPassiveListener);
        }
      }
      function removeWheelListener(elem, callback, isPassiveListener) {
        _removeWheelListener(elem, support, callback, isPassiveListener);
        if (support == "DOMMouseScroll") {
          _removeWheelListener(elem, "MozMousePixelScroll", callback, isPassiveListener);
        }
      }
      return {
        on: addWheelListener,
        off: removeWheelListener
      };
    }();
  }
});

// node_modules/svg-pan-zoom/src/utilities.js
var require_utilities = __commonJS({
  "node_modules/svg-pan-zoom/src/utilities.js"(exports, module2) {
    module2.exports = {
      extend: function(target, source) {
        target = target || {};
        for (var prop in source) {
          if (this.isObject(source[prop])) {
            target[prop] = this.extend(target[prop], source[prop]);
          } else {
            target[prop] = source[prop];
          }
        }
        return target;
      },
      isElement: function(o) {
        return o instanceof HTMLElement || o instanceof SVGElement || o instanceof SVGSVGElement || o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
      },
      isObject: function(o) {
        return Object.prototype.toString.call(o) === "[object Object]";
      },
      isNumber: function(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      },
      getSvg: function(elementOrSelector) {
        var element, svg;
        if (!this.isElement(elementOrSelector)) {
          if (typeof elementOrSelector === "string" || elementOrSelector instanceof String) {
            element = document.querySelector(elementOrSelector);
            if (!element) {
              throw new Error("Provided selector did not find any elements. Selector: " + elementOrSelector);
              return null;
            }
          } else {
            throw new Error("Provided selector is not an HTML object nor String");
            return null;
          }
        } else {
          element = elementOrSelector;
        }
        if (element.tagName.toLowerCase() === "svg") {
          svg = element;
        } else {
          if (element.tagName.toLowerCase() === "object") {
            svg = element.contentDocument.documentElement;
          } else {
            if (element.tagName.toLowerCase() === "embed") {
              svg = element.getSVGDocument().documentElement;
            } else {
              if (element.tagName.toLowerCase() === "img") {
                throw new Error('Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.');
              } else {
                throw new Error("Cannot get SVG.");
              }
              return null;
            }
          }
        }
        return svg;
      },
      proxy: function(fn, context) {
        return function() {
          return fn.apply(context, arguments);
        };
      },
      getType: function(o) {
        return Object.prototype.toString.apply(o).replace(/^\[object\s/, "").replace(/\]$/, "");
      },
      mouseAndTouchNormalize: function(evt, svg) {
        if (evt.clientX === void 0 || evt.clientX === null) {
          evt.clientX = 0;
          evt.clientY = 0;
          if (evt.touches !== void 0 && evt.touches.length) {
            if (evt.touches[0].clientX !== void 0) {
              evt.clientX = evt.touches[0].clientX;
              evt.clientY = evt.touches[0].clientY;
            } else if (evt.touches[0].pageX !== void 0) {
              var rect = svg.getBoundingClientRect();
              evt.clientX = evt.touches[0].pageX - rect.left;
              evt.clientY = evt.touches[0].pageY - rect.top;
            }
          } else if (evt.originalEvent !== void 0) {
            if (evt.originalEvent.clientX !== void 0) {
              evt.clientX = evt.originalEvent.clientX;
              evt.clientY = evt.originalEvent.clientY;
            }
          }
        }
      },
      isDblClick: function(evt, prevEvt) {
        if (evt.detail === 2) {
          return true;
        } else if (prevEvt !== void 0 && prevEvt !== null) {
          var timeStampDiff = evt.timeStamp - prevEvt.timeStamp, touchesDistance = Math.sqrt(Math.pow(evt.clientX - prevEvt.clientX, 2) + Math.pow(evt.clientY - prevEvt.clientY, 2));
          return timeStampDiff < 250 && touchesDistance < 10;
        }
        return false;
      },
      now: Date.now || function() {
        return new Date().getTime();
      },
      throttle: function(func, wait, options) {
        var that = this;
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options) {
          options = {};
        }
        var later = function() {
          previous = options.leading === false ? 0 : that.now();
          timeout = null;
          result = func.apply(context, args);
          if (!timeout) {
            context = args = null;
          }
        };
        return function() {
          var now = that.now();
          if (!previous && options.leading === false) {
            previous = now;
          }
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0 || remaining > wait) {
            clearTimeout(timeout);
            timeout = null;
            previous = now;
            result = func.apply(context, args);
            if (!timeout) {
              context = args = null;
            }
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result;
        };
      },
      createRequestAnimationFrame: function(refreshRate) {
        var timeout = null;
        if (refreshRate !== "auto" && refreshRate < 60 && refreshRate > 1) {
          timeout = Math.floor(1e3 / refreshRate);
        }
        if (timeout === null) {
          return window.requestAnimationFrame || requestTimeout(33);
        } else {
          return requestTimeout(timeout);
        }
      }
    };
    function requestTimeout(timeout) {
      return function(callback) {
        window.setTimeout(callback, timeout);
      };
    }
  }
});

// node_modules/svg-pan-zoom/src/svg-utilities.js
var require_svg_utilities = __commonJS({
  "node_modules/svg-pan-zoom/src/svg-utilities.js"(exports, module2) {
    var Utils = require_utilities();
    var _browser = "unknown";
    if (!!document.documentMode) {
      _browser = "ie";
    }
    module2.exports = {
      svgNS: "http://www.w3.org/2000/svg",
      xmlNS: "http://www.w3.org/XML/1998/namespace",
      xmlnsNS: "http://www.w3.org/2000/xmlns/",
      xlinkNS: "http://www.w3.org/1999/xlink",
      evNS: "http://www.w3.org/2001/xml-events",
      getBoundingClientRectNormalized: function(svg) {
        if (svg.clientWidth && svg.clientHeight) {
          return { width: svg.clientWidth, height: svg.clientHeight };
        } else if (!!svg.getBoundingClientRect()) {
          return svg.getBoundingClientRect();
        } else {
          throw new Error("Cannot get BoundingClientRect for SVG.");
        }
      },
      getOrCreateViewport: function(svg, selector) {
        var viewport = null;
        if (Utils.isElement(selector)) {
          viewport = selector;
        } else {
          viewport = svg.querySelector(selector);
        }
        if (!viewport) {
          var childNodes = Array.prototype.slice.call(svg.childNodes || svg.children).filter(function(el) {
            return el.nodeName !== "defs" && el.nodeName !== "#text";
          });
          if (childNodes.length === 1 && childNodes[0].nodeName === "g" && childNodes[0].getAttribute("transform") === null) {
            viewport = childNodes[0];
          }
        }
        if (!viewport) {
          var viewportId = "viewport-" + new Date().toISOString().replace(/\D/g, "");
          viewport = document.createElementNS(this.svgNS, "g");
          viewport.setAttribute("id", viewportId);
          var svgChildren = svg.childNodes || svg.children;
          if (!!svgChildren && svgChildren.length > 0) {
            for (var i = svgChildren.length; i > 0; i--) {
              if (svgChildren[svgChildren.length - i].nodeName !== "defs") {
                viewport.appendChild(svgChildren[svgChildren.length - i]);
              }
            }
          }
          svg.appendChild(viewport);
        }
        var classNames = [];
        if (viewport.getAttribute("class")) {
          classNames = viewport.getAttribute("class").split(" ");
        }
        if (!~classNames.indexOf("svg-pan-zoom_viewport")) {
          classNames.push("svg-pan-zoom_viewport");
          viewport.setAttribute("class", classNames.join(" "));
        }
        return viewport;
      },
      setupSvgAttributes: function(svg) {
        svg.setAttribute("xmlns", this.svgNS);
        svg.setAttributeNS(this.xmlnsNS, "xmlns:xlink", this.xlinkNS);
        svg.setAttributeNS(this.xmlnsNS, "xmlns:ev", this.evNS);
        if (svg.parentNode !== null) {
          var style = svg.getAttribute("style") || "";
          if (style.toLowerCase().indexOf("overflow") === -1) {
            svg.setAttribute("style", "overflow: hidden; " + style);
          }
        }
      },
      internetExplorerRedisplayInterval: 300,
      refreshDefsGlobal: Utils.throttle(function() {
        var allDefs = document.querySelectorAll("defs");
        var allDefsCount = allDefs.length;
        for (var i = 0; i < allDefsCount; i++) {
          var thisDefs = allDefs[i];
          thisDefs.parentNode.insertBefore(thisDefs, thisDefs);
        }
      }, exports ? exports.internetExplorerRedisplayInterval : null),
      setCTM: function(element, matrix, defs) {
        var that = this, s = "matrix(" + matrix.a + "," + matrix.b + "," + matrix.c + "," + matrix.d + "," + matrix.e + "," + matrix.f + ")";
        element.setAttributeNS(null, "transform", s);
        if ("transform" in element.style) {
          element.style.transform = s;
        } else if ("-ms-transform" in element.style) {
          element.style["-ms-transform"] = s;
        } else if ("-webkit-transform" in element.style) {
          element.style["-webkit-transform"] = s;
        }
        if (_browser === "ie" && !!defs) {
          defs.parentNode.insertBefore(defs, defs);
          window.setTimeout(function() {
            that.refreshDefsGlobal();
          }, that.internetExplorerRedisplayInterval);
        }
      },
      getEventPoint: function(evt, svg) {
        var point = svg.createSVGPoint();
        Utils.mouseAndTouchNormalize(evt, svg);
        point.x = evt.clientX;
        point.y = evt.clientY;
        return point;
      },
      getSvgCenterPoint: function(svg, width, height) {
        return this.createSVGPoint(svg, width / 2, height / 2);
      },
      createSVGPoint: function(svg, x, y) {
        var point = svg.createSVGPoint();
        point.x = x;
        point.y = y;
        return point;
      }
    };
  }
});

// node_modules/svg-pan-zoom/src/control-icons.js
var require_control_icons = __commonJS({
  "node_modules/svg-pan-zoom/src/control-icons.js"(exports, module2) {
    var SvgUtils = require_svg_utilities();
    module2.exports = {
      enable: function(instance) {
        var defs = instance.svg.querySelector("defs");
        if (!defs) {
          defs = document.createElementNS(SvgUtils.svgNS, "defs");
          instance.svg.appendChild(defs);
        }
        var styleEl = defs.querySelector("style#svg-pan-zoom-controls-styles");
        if (!styleEl) {
          var style = document.createElementNS(SvgUtils.svgNS, "style");
          style.setAttribute("id", "svg-pan-zoom-controls-styles");
          style.setAttribute("type", "text/css");
          style.textContent = ".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }";
          defs.appendChild(style);
        }
        var zoomGroup = document.createElementNS(SvgUtils.svgNS, "g");
        zoomGroup.setAttribute("id", "svg-pan-zoom-controls");
        zoomGroup.setAttribute("transform", "translate(" + (instance.width - 70) + " " + (instance.height - 76) + ") scale(0.75)");
        zoomGroup.setAttribute("class", "svg-pan-zoom-control");
        zoomGroup.appendChild(this._createZoomIn(instance));
        zoomGroup.appendChild(this._createZoomReset(instance));
        zoomGroup.appendChild(this._createZoomOut(instance));
        instance.svg.appendChild(zoomGroup);
        instance.controlIcons = zoomGroup;
      },
      _createZoomIn: function(instance) {
        var zoomIn = document.createElementNS(SvgUtils.svgNS, "g");
        zoomIn.setAttribute("id", "svg-pan-zoom-zoom-in");
        zoomIn.setAttribute("transform", "translate(30.5 5) scale(0.015)");
        zoomIn.setAttribute("class", "svg-pan-zoom-control");
        zoomIn.addEventListener("click", function() {
          instance.getPublicInstance().zoomIn();
        }, false);
        zoomIn.addEventListener("touchstart", function() {
          instance.getPublicInstance().zoomIn();
        }, false);
        var zoomInBackground = document.createElementNS(SvgUtils.svgNS, "rect");
        zoomInBackground.setAttribute("x", "0");
        zoomInBackground.setAttribute("y", "0");
        zoomInBackground.setAttribute("width", "1500");
        zoomInBackground.setAttribute("height", "1400");
        zoomInBackground.setAttribute("class", "svg-pan-zoom-control-background");
        zoomIn.appendChild(zoomInBackground);
        var zoomInShape = document.createElementNS(SvgUtils.svgNS, "path");
        zoomInShape.setAttribute("d", "M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z");
        zoomInShape.setAttribute("class", "svg-pan-zoom-control-element");
        zoomIn.appendChild(zoomInShape);
        return zoomIn;
      },
      _createZoomReset: function(instance) {
        var resetPanZoomControl = document.createElementNS(SvgUtils.svgNS, "g");
        resetPanZoomControl.setAttribute("id", "svg-pan-zoom-reset-pan-zoom");
        resetPanZoomControl.setAttribute("transform", "translate(5 35) scale(0.4)");
        resetPanZoomControl.setAttribute("class", "svg-pan-zoom-control");
        resetPanZoomControl.addEventListener("click", function() {
          instance.getPublicInstance().reset();
        }, false);
        resetPanZoomControl.addEventListener("touchstart", function() {
          instance.getPublicInstance().reset();
        }, false);
        var resetPanZoomControlBackground = document.createElementNS(SvgUtils.svgNS, "rect");
        resetPanZoomControlBackground.setAttribute("x", "2");
        resetPanZoomControlBackground.setAttribute("y", "2");
        resetPanZoomControlBackground.setAttribute("width", "182");
        resetPanZoomControlBackground.setAttribute("height", "58");
        resetPanZoomControlBackground.setAttribute("class", "svg-pan-zoom-control-background");
        resetPanZoomControl.appendChild(resetPanZoomControlBackground);
        var resetPanZoomControlShape1 = document.createElementNS(SvgUtils.svgNS, "path");
        resetPanZoomControlShape1.setAttribute("d", "M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z");
        resetPanZoomControlShape1.setAttribute("class", "svg-pan-zoom-control-element");
        resetPanZoomControl.appendChild(resetPanZoomControlShape1);
        var resetPanZoomControlShape2 = document.createElementNS(SvgUtils.svgNS, "path");
        resetPanZoomControlShape2.setAttribute("d", "M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z");
        resetPanZoomControlShape2.setAttribute("class", "svg-pan-zoom-control-element");
        resetPanZoomControl.appendChild(resetPanZoomControlShape2);
        return resetPanZoomControl;
      },
      _createZoomOut: function(instance) {
        var zoomOut = document.createElementNS(SvgUtils.svgNS, "g");
        zoomOut.setAttribute("id", "svg-pan-zoom-zoom-out");
        zoomOut.setAttribute("transform", "translate(30.5 70) scale(0.015)");
        zoomOut.setAttribute("class", "svg-pan-zoom-control");
        zoomOut.addEventListener("click", function() {
          instance.getPublicInstance().zoomOut();
        }, false);
        zoomOut.addEventListener("touchstart", function() {
          instance.getPublicInstance().zoomOut();
        }, false);
        var zoomOutBackground = document.createElementNS(SvgUtils.svgNS, "rect");
        zoomOutBackground.setAttribute("x", "0");
        zoomOutBackground.setAttribute("y", "0");
        zoomOutBackground.setAttribute("width", "1500");
        zoomOutBackground.setAttribute("height", "1400");
        zoomOutBackground.setAttribute("class", "svg-pan-zoom-control-background");
        zoomOut.appendChild(zoomOutBackground);
        var zoomOutShape = document.createElementNS(SvgUtils.svgNS, "path");
        zoomOutShape.setAttribute("d", "M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z");
        zoomOutShape.setAttribute("class", "svg-pan-zoom-control-element");
        zoomOut.appendChild(zoomOutShape);
        return zoomOut;
      },
      disable: function(instance) {
        if (instance.controlIcons) {
          instance.controlIcons.parentNode.removeChild(instance.controlIcons);
          instance.controlIcons = null;
        }
      }
    };
  }
});

// node_modules/svg-pan-zoom/src/shadow-viewport.js
var require_shadow_viewport = __commonJS({
  "node_modules/svg-pan-zoom/src/shadow-viewport.js"(exports, module2) {
    var SvgUtils = require_svg_utilities();
    var Utils = require_utilities();
    var ShadowViewport = function(viewport, options) {
      this.init(viewport, options);
    };
    ShadowViewport.prototype.init = function(viewport, options) {
      this.viewport = viewport;
      this.options = options;
      this.originalState = { zoom: 1, x: 0, y: 0 };
      this.activeState = { zoom: 1, x: 0, y: 0 };
      this.updateCTMCached = Utils.proxy(this.updateCTM, this);
      this.requestAnimationFrame = Utils.createRequestAnimationFrame(this.options.refreshRate);
      this.viewBox = { x: 0, y: 0, width: 0, height: 0 };
      this.cacheViewBox();
      var newCTM = this.processCTM();
      this.setCTM(newCTM);
      this.updateCTM();
    };
    ShadowViewport.prototype.cacheViewBox = function() {
      var svgViewBox = this.options.svg.getAttribute("viewBox");
      if (svgViewBox) {
        var viewBoxValues = svgViewBox.split(/[\s\,]/).filter(function(v) {
          return v;
        }).map(parseFloat);
        this.viewBox.x = viewBoxValues[0];
        this.viewBox.y = viewBoxValues[1];
        this.viewBox.width = viewBoxValues[2];
        this.viewBox.height = viewBoxValues[3];
        var zoom = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
        this.activeState.zoom = zoom;
        this.activeState.x = (this.options.width - this.viewBox.width * zoom) / 2;
        this.activeState.y = (this.options.height - this.viewBox.height * zoom) / 2;
        this.updateCTMOnNextFrame();
        this.options.svg.removeAttribute("viewBox");
      } else {
        this.simpleViewBoxCache();
      }
    };
    ShadowViewport.prototype.simpleViewBoxCache = function() {
      var bBox = this.viewport.getBBox();
      this.viewBox.x = bBox.x;
      this.viewBox.y = bBox.y;
      this.viewBox.width = bBox.width;
      this.viewBox.height = bBox.height;
    };
    ShadowViewport.prototype.getViewBox = function() {
      return Utils.extend({}, this.viewBox);
    };
    ShadowViewport.prototype.processCTM = function() {
      var newCTM = this.getCTM();
      if (this.options.fit || this.options.contain) {
        var newScale;
        if (this.options.fit) {
          newScale = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
        } else {
          newScale = Math.max(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
        }
        newCTM.a = newScale;
        newCTM.d = newScale;
        newCTM.e = -this.viewBox.x * newScale;
        newCTM.f = -this.viewBox.y * newScale;
      }
      if (this.options.center) {
        var offsetX = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * newCTM.a) * 0.5, offsetY = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * newCTM.a) * 0.5;
        newCTM.e = offsetX;
        newCTM.f = offsetY;
      }
      this.originalState.zoom = newCTM.a;
      this.originalState.x = newCTM.e;
      this.originalState.y = newCTM.f;
      return newCTM;
    };
    ShadowViewport.prototype.getOriginalState = function() {
      return Utils.extend({}, this.originalState);
    };
    ShadowViewport.prototype.getState = function() {
      return Utils.extend({}, this.activeState);
    };
    ShadowViewport.prototype.getZoom = function() {
      return this.activeState.zoom;
    };
    ShadowViewport.prototype.getRelativeZoom = function() {
      return this.activeState.zoom / this.originalState.zoom;
    };
    ShadowViewport.prototype.computeRelativeZoom = function(scale) {
      return scale / this.originalState.zoom;
    };
    ShadowViewport.prototype.getPan = function() {
      return { x: this.activeState.x, y: this.activeState.y };
    };
    ShadowViewport.prototype.getCTM = function() {
      var safeCTM = this.options.svg.createSVGMatrix();
      safeCTM.a = this.activeState.zoom;
      safeCTM.b = 0;
      safeCTM.c = 0;
      safeCTM.d = this.activeState.zoom;
      safeCTM.e = this.activeState.x;
      safeCTM.f = this.activeState.y;
      return safeCTM;
    };
    ShadowViewport.prototype.setCTM = function(newCTM) {
      var willZoom = this.isZoomDifferent(newCTM), willPan = this.isPanDifferent(newCTM);
      if (willZoom || willPan) {
        if (willZoom) {
          if (this.options.beforeZoom(this.getRelativeZoom(), this.computeRelativeZoom(newCTM.a)) === false) {
            newCTM.a = newCTM.d = this.activeState.zoom;
            willZoom = false;
          } else {
            this.updateCache(newCTM);
            this.options.onZoom(this.getRelativeZoom());
          }
        }
        if (willPan) {
          var preventPan = this.options.beforePan(this.getPan(), {
            x: newCTM.e,
            y: newCTM.f
          }), preventPanX = false, preventPanY = false;
          if (preventPan === false) {
            newCTM.e = this.getPan().x;
            newCTM.f = this.getPan().y;
            preventPanX = preventPanY = true;
          } else if (Utils.isObject(preventPan)) {
            if (preventPan.x === false) {
              newCTM.e = this.getPan().x;
              preventPanX = true;
            } else if (Utils.isNumber(preventPan.x)) {
              newCTM.e = preventPan.x;
            }
            if (preventPan.y === false) {
              newCTM.f = this.getPan().y;
              preventPanY = true;
            } else if (Utils.isNumber(preventPan.y)) {
              newCTM.f = preventPan.y;
            }
          }
          if (preventPanX && preventPanY || !this.isPanDifferent(newCTM)) {
            willPan = false;
          } else {
            this.updateCache(newCTM);
            this.options.onPan(this.getPan());
          }
        }
        if (willZoom || willPan) {
          this.updateCTMOnNextFrame();
        }
      }
    };
    ShadowViewport.prototype.isZoomDifferent = function(newCTM) {
      return this.activeState.zoom !== newCTM.a;
    };
    ShadowViewport.prototype.isPanDifferent = function(newCTM) {
      return this.activeState.x !== newCTM.e || this.activeState.y !== newCTM.f;
    };
    ShadowViewport.prototype.updateCache = function(newCTM) {
      this.activeState.zoom = newCTM.a;
      this.activeState.x = newCTM.e;
      this.activeState.y = newCTM.f;
    };
    ShadowViewport.prototype.pendingUpdate = false;
    ShadowViewport.prototype.updateCTMOnNextFrame = function() {
      if (!this.pendingUpdate) {
        this.pendingUpdate = true;
        this.requestAnimationFrame.call(window, this.updateCTMCached);
      }
    };
    ShadowViewport.prototype.updateCTM = function() {
      var ctm = this.getCTM();
      SvgUtils.setCTM(this.viewport, ctm, this.defs);
      this.pendingUpdate = false;
      if (this.options.onUpdatedCTM) {
        this.options.onUpdatedCTM(ctm);
      }
    };
    module2.exports = function(viewport, options) {
      return new ShadowViewport(viewport, options);
    };
  }
});

// node_modules/svg-pan-zoom/src/svg-pan-zoom.js
var require_svg_pan_zoom = __commonJS({
  "node_modules/svg-pan-zoom/src/svg-pan-zoom.js"(exports, module2) {
    var Wheel = require_uniwheel();
    var ControlIcons = require_control_icons();
    var Utils = require_utilities();
    var SvgUtils = require_svg_utilities();
    var ShadowViewport = require_shadow_viewport();
    var SvgPanZoom = function(svg, options) {
      this.init(svg, options);
    };
    var optionsDefaults = {
      viewportSelector: ".svg-pan-zoom_viewport",
      panEnabled: true,
      controlIconsEnabled: false,
      zoomEnabled: true,
      dblClickZoomEnabled: true,
      mouseWheelZoomEnabled: true,
      preventMouseEventsDefault: true,
      zoomScaleSensitivity: 0.1,
      minZoom: 0.5,
      maxZoom: 10,
      fit: true,
      contain: false,
      center: true,
      refreshRate: "auto",
      beforeZoom: null,
      onZoom: null,
      beforePan: null,
      onPan: null,
      customEventsHandler: null,
      eventsListenerElement: null,
      onUpdatedCTM: null
    };
    var passiveListenerOption = { passive: true };
    SvgPanZoom.prototype.init = function(svg, options) {
      var that = this;
      this.svg = svg;
      this.defs = svg.querySelector("defs");
      SvgUtils.setupSvgAttributes(this.svg);
      this.options = Utils.extend(Utils.extend({}, optionsDefaults), options);
      this.state = "none";
      var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(svg);
      this.width = boundingClientRectNormalized.width;
      this.height = boundingClientRectNormalized.height;
      this.viewport = ShadowViewport(SvgUtils.getOrCreateViewport(this.svg, this.options.viewportSelector), {
        svg: this.svg,
        width: this.width,
        height: this.height,
        fit: this.options.fit,
        contain: this.options.contain,
        center: this.options.center,
        refreshRate: this.options.refreshRate,
        beforeZoom: function(oldScale, newScale) {
          if (that.viewport && that.options.beforeZoom) {
            return that.options.beforeZoom(oldScale, newScale);
          }
        },
        onZoom: function(scale) {
          if (that.viewport && that.options.onZoom) {
            return that.options.onZoom(scale);
          }
        },
        beforePan: function(oldPoint, newPoint) {
          if (that.viewport && that.options.beforePan) {
            return that.options.beforePan(oldPoint, newPoint);
          }
        },
        onPan: function(point) {
          if (that.viewport && that.options.onPan) {
            return that.options.onPan(point);
          }
        },
        onUpdatedCTM: function(ctm) {
          if (that.viewport && that.options.onUpdatedCTM) {
            return that.options.onUpdatedCTM(ctm);
          }
        }
      });
      var publicInstance = this.getPublicInstance();
      publicInstance.setBeforeZoom(this.options.beforeZoom);
      publicInstance.setOnZoom(this.options.onZoom);
      publicInstance.setBeforePan(this.options.beforePan);
      publicInstance.setOnPan(this.options.onPan);
      publicInstance.setOnUpdatedCTM(this.options.onUpdatedCTM);
      if (this.options.controlIconsEnabled) {
        ControlIcons.enable(this);
      }
      this.lastMouseWheelEventTime = Date.now();
      this.setupHandlers();
    };
    SvgPanZoom.prototype.setupHandlers = function() {
      var that = this, prevEvt = null;
      this.eventListeners = {
        mousedown: function(evt) {
          var result = that.handleMouseDown(evt, prevEvt);
          prevEvt = evt;
          return result;
        },
        touchstart: function(evt) {
          var result = that.handleMouseDown(evt, prevEvt);
          prevEvt = evt;
          return result;
        },
        mouseup: function(evt) {
          return that.handleMouseUp(evt);
        },
        touchend: function(evt) {
          return that.handleMouseUp(evt);
        },
        mousemove: function(evt) {
          return that.handleMouseMove(evt);
        },
        touchmove: function(evt) {
          return that.handleMouseMove(evt);
        },
        mouseleave: function(evt) {
          return that.handleMouseUp(evt);
        },
        touchleave: function(evt) {
          return that.handleMouseUp(evt);
        },
        touchcancel: function(evt) {
          return that.handleMouseUp(evt);
        }
      };
      if (this.options.customEventsHandler != null) {
        this.options.customEventsHandler.init({
          svgElement: this.svg,
          eventsListenerElement: this.options.eventsListenerElement,
          instance: this.getPublicInstance()
        });
        var haltEventListeners = this.options.customEventsHandler.haltEventListeners;
        if (haltEventListeners && haltEventListeners.length) {
          for (var i = haltEventListeners.length - 1; i >= 0; i--) {
            if (this.eventListeners.hasOwnProperty(haltEventListeners[i])) {
              delete this.eventListeners[haltEventListeners[i]];
            }
          }
        }
      }
      for (var event in this.eventListeners) {
        (this.options.eventsListenerElement || this.svg).addEventListener(event, this.eventListeners[event], !this.options.preventMouseEventsDefault ? passiveListenerOption : false);
      }
      if (this.options.mouseWheelZoomEnabled) {
        this.options.mouseWheelZoomEnabled = false;
        this.enableMouseWheelZoom();
      }
    };
    SvgPanZoom.prototype.enableMouseWheelZoom = function() {
      if (!this.options.mouseWheelZoomEnabled) {
        var that = this;
        this.wheelListener = function(evt) {
          return that.handleMouseWheel(evt);
        };
        var isPassiveListener = !this.options.preventMouseEventsDefault;
        Wheel.on(this.options.eventsListenerElement || this.svg, this.wheelListener, isPassiveListener);
        this.options.mouseWheelZoomEnabled = true;
      }
    };
    SvgPanZoom.prototype.disableMouseWheelZoom = function() {
      if (this.options.mouseWheelZoomEnabled) {
        var isPassiveListener = !this.options.preventMouseEventsDefault;
        Wheel.off(this.options.eventsListenerElement || this.svg, this.wheelListener, isPassiveListener);
        this.options.mouseWheelZoomEnabled = false;
      }
    };
    SvgPanZoom.prototype.handleMouseWheel = function(evt) {
      if (!this.options.zoomEnabled || this.state !== "none") {
        return;
      }
      if (this.options.preventMouseEventsDefault) {
        if (evt.preventDefault) {
          evt.preventDefault();
        } else {
          evt.returnValue = false;
        }
      }
      var delta = evt.deltaY || 1, timeDelta = Date.now() - this.lastMouseWheelEventTime, divider = 3 + Math.max(0, 30 - timeDelta);
      this.lastMouseWheelEventTime = Date.now();
      if ("deltaMode" in evt && evt.deltaMode === 0 && evt.wheelDelta) {
        delta = evt.deltaY === 0 ? 0 : Math.abs(evt.wheelDelta) / evt.deltaY;
      }
      delta = -0.3 < delta && delta < 0.3 ? delta : (delta > 0 ? 1 : -1) * Math.log(Math.abs(delta) + 10) / divider;
      var inversedScreenCTM = this.svg.getScreenCTM().inverse(), relativeMousePoint = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(inversedScreenCTM), zoom = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * delta);
      this.zoomAtPoint(zoom, relativeMousePoint);
    };
    SvgPanZoom.prototype.zoomAtPoint = function(zoomScale, point, zoomAbsolute) {
      var originalState = this.viewport.getOriginalState();
      if (!zoomAbsolute) {
        if (this.getZoom() * zoomScale < this.options.minZoom * originalState.zoom) {
          zoomScale = this.options.minZoom * originalState.zoom / this.getZoom();
        } else if (this.getZoom() * zoomScale > this.options.maxZoom * originalState.zoom) {
          zoomScale = this.options.maxZoom * originalState.zoom / this.getZoom();
        }
      } else {
        zoomScale = Math.max(this.options.minZoom * originalState.zoom, Math.min(this.options.maxZoom * originalState.zoom, zoomScale));
        zoomScale = zoomScale / this.getZoom();
      }
      var oldCTM = this.viewport.getCTM(), relativePoint = point.matrixTransform(oldCTM.inverse()), modifier = this.svg.createSVGMatrix().translate(relativePoint.x, relativePoint.y).scale(zoomScale).translate(-relativePoint.x, -relativePoint.y), newCTM = oldCTM.multiply(modifier);
      if (newCTM.a !== oldCTM.a) {
        this.viewport.setCTM(newCTM);
      }
    };
    SvgPanZoom.prototype.zoom = function(scale, absolute) {
      this.zoomAtPoint(scale, SvgUtils.getSvgCenterPoint(this.svg, this.width, this.height), absolute);
    };
    SvgPanZoom.prototype.publicZoom = function(scale, absolute) {
      if (absolute) {
        scale = this.computeFromRelativeZoom(scale);
      }
      this.zoom(scale, absolute);
    };
    SvgPanZoom.prototype.publicZoomAtPoint = function(scale, point, absolute) {
      if (absolute) {
        scale = this.computeFromRelativeZoom(scale);
      }
      if (Utils.getType(point) !== "SVGPoint") {
        if ("x" in point && "y" in point) {
          point = SvgUtils.createSVGPoint(this.svg, point.x, point.y);
        } else {
          throw new Error("Given point is invalid");
        }
      }
      this.zoomAtPoint(scale, point, absolute);
    };
    SvgPanZoom.prototype.getZoom = function() {
      return this.viewport.getZoom();
    };
    SvgPanZoom.prototype.getRelativeZoom = function() {
      return this.viewport.getRelativeZoom();
    };
    SvgPanZoom.prototype.computeFromRelativeZoom = function(zoom) {
      return zoom * this.viewport.getOriginalState().zoom;
    };
    SvgPanZoom.prototype.resetZoom = function() {
      var originalState = this.viewport.getOriginalState();
      this.zoom(originalState.zoom, true);
    };
    SvgPanZoom.prototype.resetPan = function() {
      this.pan(this.viewport.getOriginalState());
    };
    SvgPanZoom.prototype.reset = function() {
      this.resetZoom();
      this.resetPan();
    };
    SvgPanZoom.prototype.handleDblClick = function(evt) {
      if (this.options.preventMouseEventsDefault) {
        if (evt.preventDefault) {
          evt.preventDefault();
        } else {
          evt.returnValue = false;
        }
      }
      if (this.options.controlIconsEnabled) {
        var targetClass = evt.target.getAttribute("class") || "";
        if (targetClass.indexOf("svg-pan-zoom-control") > -1) {
          return false;
        }
      }
      var zoomFactor;
      if (evt.shiftKey) {
        zoomFactor = 1 / ((1 + this.options.zoomScaleSensitivity) * 2);
      } else {
        zoomFactor = (1 + this.options.zoomScaleSensitivity) * 2;
      }
      var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.svg.getScreenCTM().inverse());
      this.zoomAtPoint(zoomFactor, point);
    };
    SvgPanZoom.prototype.handleMouseDown = function(evt, prevEvt) {
      if (this.options.preventMouseEventsDefault) {
        if (evt.preventDefault) {
          evt.preventDefault();
        } else {
          evt.returnValue = false;
        }
      }
      Utils.mouseAndTouchNormalize(evt, this.svg);
      if (this.options.dblClickZoomEnabled && Utils.isDblClick(evt, prevEvt)) {
        this.handleDblClick(evt);
      } else {
        this.state = "pan";
        this.firstEventCTM = this.viewport.getCTM();
        this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse());
      }
    };
    SvgPanZoom.prototype.handleMouseMove = function(evt) {
      if (this.options.preventMouseEventsDefault) {
        if (evt.preventDefault) {
          evt.preventDefault();
        } else {
          evt.returnValue = false;
        }
      }
      if (this.state === "pan" && this.options.panEnabled) {
        var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse()), viewportCTM = this.firstEventCTM.translate(point.x - this.stateOrigin.x, point.y - this.stateOrigin.y);
        this.viewport.setCTM(viewportCTM);
      }
    };
    SvgPanZoom.prototype.handleMouseUp = function(evt) {
      if (this.options.preventMouseEventsDefault) {
        if (evt.preventDefault) {
          evt.preventDefault();
        } else {
          evt.returnValue = false;
        }
      }
      if (this.state === "pan") {
        this.state = "none";
      }
    };
    SvgPanZoom.prototype.fit = function() {
      var viewBox = this.viewport.getViewBox(), newScale = Math.min(this.width / viewBox.width, this.height / viewBox.height);
      this.zoom(newScale, true);
    };
    SvgPanZoom.prototype.contain = function() {
      var viewBox = this.viewport.getViewBox(), newScale = Math.max(this.width / viewBox.width, this.height / viewBox.height);
      this.zoom(newScale, true);
    };
    SvgPanZoom.prototype.center = function() {
      var viewBox = this.viewport.getViewBox(), offsetX = (this.width - (viewBox.width + viewBox.x * 2) * this.getZoom()) * 0.5, offsetY = (this.height - (viewBox.height + viewBox.y * 2) * this.getZoom()) * 0.5;
      this.getPublicInstance().pan({ x: offsetX, y: offsetY });
    };
    SvgPanZoom.prototype.updateBBox = function() {
      this.viewport.simpleViewBoxCache();
    };
    SvgPanZoom.prototype.pan = function(point) {
      var viewportCTM = this.viewport.getCTM();
      viewportCTM.e = point.x;
      viewportCTM.f = point.y;
      this.viewport.setCTM(viewportCTM);
    };
    SvgPanZoom.prototype.panBy = function(point) {
      var viewportCTM = this.viewport.getCTM();
      viewportCTM.e += point.x;
      viewportCTM.f += point.y;
      this.viewport.setCTM(viewportCTM);
    };
    SvgPanZoom.prototype.getPan = function() {
      var state = this.viewport.getState();
      return { x: state.x, y: state.y };
    };
    SvgPanZoom.prototype.resize = function() {
      var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(this.svg);
      this.width = boundingClientRectNormalized.width;
      this.height = boundingClientRectNormalized.height;
      var viewport = this.viewport;
      viewport.options.width = this.width;
      viewport.options.height = this.height;
      viewport.processCTM();
      if (this.options.controlIconsEnabled) {
        this.getPublicInstance().disableControlIcons();
        this.getPublicInstance().enableControlIcons();
      }
    };
    SvgPanZoom.prototype.destroy = function() {
      var that = this;
      this.beforeZoom = null;
      this.onZoom = null;
      this.beforePan = null;
      this.onPan = null;
      this.onUpdatedCTM = null;
      if (this.options.customEventsHandler != null) {
        this.options.customEventsHandler.destroy({
          svgElement: this.svg,
          eventsListenerElement: this.options.eventsListenerElement,
          instance: this.getPublicInstance()
        });
      }
      for (var event in this.eventListeners) {
        (this.options.eventsListenerElement || this.svg).removeEventListener(event, this.eventListeners[event], !this.options.preventMouseEventsDefault ? passiveListenerOption : false);
      }
      this.disableMouseWheelZoom();
      this.getPublicInstance().disableControlIcons();
      this.reset();
      instancesStore = instancesStore.filter(function(instance) {
        return instance.svg !== that.svg;
      });
      delete this.options;
      delete this.viewport;
      delete this.publicInstance;
      delete this.pi;
      this.getPublicInstance = function() {
        return null;
      };
    };
    SvgPanZoom.prototype.getPublicInstance = function() {
      var that = this;
      if (!this.publicInstance) {
        this.publicInstance = this.pi = {
          enablePan: function() {
            that.options.panEnabled = true;
            return that.pi;
          },
          disablePan: function() {
            that.options.panEnabled = false;
            return that.pi;
          },
          isPanEnabled: function() {
            return !!that.options.panEnabled;
          },
          pan: function(point) {
            that.pan(point);
            return that.pi;
          },
          panBy: function(point) {
            that.panBy(point);
            return that.pi;
          },
          getPan: function() {
            return that.getPan();
          },
          setBeforePan: function(fn) {
            that.options.beforePan = fn === null ? null : Utils.proxy(fn, that.publicInstance);
            return that.pi;
          },
          setOnPan: function(fn) {
            that.options.onPan = fn === null ? null : Utils.proxy(fn, that.publicInstance);
            return that.pi;
          },
          enableZoom: function() {
            that.options.zoomEnabled = true;
            return that.pi;
          },
          disableZoom: function() {
            that.options.zoomEnabled = false;
            return that.pi;
          },
          isZoomEnabled: function() {
            return !!that.options.zoomEnabled;
          },
          enableControlIcons: function() {
            if (!that.options.controlIconsEnabled) {
              that.options.controlIconsEnabled = true;
              ControlIcons.enable(that);
            }
            return that.pi;
          },
          disableControlIcons: function() {
            if (that.options.controlIconsEnabled) {
              that.options.controlIconsEnabled = false;
              ControlIcons.disable(that);
            }
            return that.pi;
          },
          isControlIconsEnabled: function() {
            return !!that.options.controlIconsEnabled;
          },
          enableDblClickZoom: function() {
            that.options.dblClickZoomEnabled = true;
            return that.pi;
          },
          disableDblClickZoom: function() {
            that.options.dblClickZoomEnabled = false;
            return that.pi;
          },
          isDblClickZoomEnabled: function() {
            return !!that.options.dblClickZoomEnabled;
          },
          enableMouseWheelZoom: function() {
            that.enableMouseWheelZoom();
            return that.pi;
          },
          disableMouseWheelZoom: function() {
            that.disableMouseWheelZoom();
            return that.pi;
          },
          isMouseWheelZoomEnabled: function() {
            return !!that.options.mouseWheelZoomEnabled;
          },
          setZoomScaleSensitivity: function(scale) {
            that.options.zoomScaleSensitivity = scale;
            return that.pi;
          },
          setMinZoom: function(zoom) {
            that.options.minZoom = zoom;
            return that.pi;
          },
          setMaxZoom: function(zoom) {
            that.options.maxZoom = zoom;
            return that.pi;
          },
          setBeforeZoom: function(fn) {
            that.options.beforeZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);
            return that.pi;
          },
          setOnZoom: function(fn) {
            that.options.onZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);
            return that.pi;
          },
          zoom: function(scale) {
            that.publicZoom(scale, true);
            return that.pi;
          },
          zoomBy: function(scale) {
            that.publicZoom(scale, false);
            return that.pi;
          },
          zoomAtPoint: function(scale, point) {
            that.publicZoomAtPoint(scale, point, true);
            return that.pi;
          },
          zoomAtPointBy: function(scale, point) {
            that.publicZoomAtPoint(scale, point, false);
            return that.pi;
          },
          zoomIn: function() {
            this.zoomBy(1 + that.options.zoomScaleSensitivity);
            return that.pi;
          },
          zoomOut: function() {
            this.zoomBy(1 / (1 + that.options.zoomScaleSensitivity));
            return that.pi;
          },
          getZoom: function() {
            return that.getRelativeZoom();
          },
          setOnUpdatedCTM: function(fn) {
            that.options.onUpdatedCTM = fn === null ? null : Utils.proxy(fn, that.publicInstance);
            return that.pi;
          },
          resetZoom: function() {
            that.resetZoom();
            return that.pi;
          },
          resetPan: function() {
            that.resetPan();
            return that.pi;
          },
          reset: function() {
            that.reset();
            return that.pi;
          },
          fit: function() {
            that.fit();
            return that.pi;
          },
          contain: function() {
            that.contain();
            return that.pi;
          },
          center: function() {
            that.center();
            return that.pi;
          },
          updateBBox: function() {
            that.updateBBox();
            return that.pi;
          },
          resize: function() {
            that.resize();
            return that.pi;
          },
          getSizes: function() {
            return {
              width: that.width,
              height: that.height,
              realZoom: that.getZoom(),
              viewBox: that.viewport.getViewBox()
            };
          },
          destroy: function() {
            that.destroy();
            return that.pi;
          }
        };
      }
      return this.publicInstance;
    };
    var instancesStore = [];
    var svgPanZoom = function(elementOrSelector, options) {
      var svg = Utils.getSvg(elementOrSelector);
      if (svg === null) {
        return null;
      } else {
        for (var i = instancesStore.length - 1; i >= 0; i--) {
          if (instancesStore[i].svg === svg) {
            return instancesStore[i].instance.getPublicInstance();
          }
        }
        instancesStore.push({
          svg,
          instance: new SvgPanZoom(svg, options)
        });
        return instancesStore[instancesStore.length - 1].instance.getPublicInstance();
      }
    };
    module2.exports = svgPanZoom;
  }
});

// node_modules/svg-pan-zoom/src/browserify.js
var require_browserify = __commonJS({
  "node_modules/svg-pan-zoom/src/browserify.js"(exports, module2) {
    var SvgPanZoom = require_svg_pan_zoom();
    module2.exports = SvgPanZoom;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ZKNavigationPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian17 = require("obsidian");

// src/lang/locale/zh.ts
var zh_default = {
  "ZK main notes": "\u4E3B\u7B14\u8BB0",
  "Main notes folder location": "\u26A0\u4E3B\u7B14\u8BB0\u6587\u4EF6\u5B58\u653E\u4F4D\u7F6E",
  "Specify a folder location to identify main notes": "\u6307\u5B9A\u4E3B\u7B14\u8BB0\u7684\u6587\u4EF6\u5939",
  "Example: folder1/folder2": "\u6BD4\u5982: \u6587\u4EF6\u5939/\u5B50\u6587\u4EF6\u5939",
  "Main notes tag": "\u4E3B\u7B14\u8BB0\u6807\u7B7E",
  "Specify a tag to identify main notes": "\u6307\u5B9A\u4E3B\u7B14\u8BB0\u7684\u6807\u7B7E\uFF08\u53EF\u9009\uFF09",
  "Note ID field options": "\u26A0ID(\u7B14\u8BB0\u7F16\u53F7)\u5B57\u6BB5\u9009\u9879",
  "Option 1: Filename is note ID": "\u9009\u98791: \u6587\u4EF6\u540D\u4F5C\u4E3AID",
  "Option 2: Metadata is note ID": "\u9009\u98792: \u7B14\u8BB0\u5C5E\u6027\u4F5C\u4E3AID",
  "Option 3: Prefix of filename is note ID": "\u9009\u98793: \u6587\u4EF6\u540D\u524D\u7F00\u4E3AID",
  "Specify a frontmatter field for note's title": "\u26A0\u6307\u5B9A\u4E00\u4E2A\u5C5E\u6027\u540D\u79F0\u4F5C\u4E3A\u6587\u5B57\u6807\u9898",
  "Specify a frontmatter field for note's ID": "\u26A0\u6307\u5B9A\u4E00\u4E2A\u5C5E\u6027\u540D\u79F0\u4F5C\u4E3AID",
  "Specify a separator between ID and title": "\u26A0\u6307\u5B9AID\u548C\u6587\u5B57\u6807\u9898\u7684\u5206\u9694\u7B26",
  '" "(blank)': '" "(\u7A7A\u683C)',
  '"-"(hyphen)': '"-"(\u6A2A\u7EBF)',
  '"_"(underscore)': '"_"(\u4E0B\u5212\u7EBF)',
  "Retrieval": "\u68C0\u7D22\u8BBE\u7F6E",
  "Indexes folder location": "\u26A0\u5173\u952E\u8BCD\u6587\u4EF6\u5B58\u653E\u4F4D\u7F6E",
  "index_description": "\u5173\u952E\u8BCD\u6587\u4EF6\u662F\u6307\u4EE5\u5173\u952E\u8BCD\u4E3A\u6587\u4EF6\u540D\uFF0C\u5185\u5BB9\u5305\u542B\u5C11\u91CF\u4E3B\u7B14\u8BB0\u51FA\u94FE\u7684.md\u6587\u4EF6.",
  "zk-index-graph-view": "\u5206\u652F\u89C6\u56FE",
  "Name of index button": "\u6309\u94AE\u540D\u79F0",
  "Suggest mode of index modal": "\u5173\u952E\u8BCD\u67E5\u627E\u6A21\u5F0F",
  "Suggest mode of main note modal": "\u4E3B\u7B14\u8BB0\u67E5\u627E\u6A21\u5F0F",
  "Keyword Order": "\u987A\u5E8F\u67E5\u627E",
  "Fuzzy Suggest": "\u6A21\u7CCA\u67E5\u627E",
  "ID Order": "\u987A\u5E8F\u67E5\u627E",
  "Set red dash line for nodes with ID ends with letter": "ID(\u7B14\u8BB0\u7F16\u53F7)\u4E3A\u5B57\u6BCD\u7ED3\u5C3E\u7684\u8282\u70B9\u8BBE\u7F6E\u7EA2\u8272\u865A\u7EBF\u6846",
  "In order to distinguish nodes which ID ends with letter and number": "\u533A\u5206: \u6570\u5B57\u7ED3\u5C3EID vs \u5B57\u6BCD\u7ED3\u5C3EID",
  "Fold node toggle": "\u6298\u53E0\u5F00\u5173",
  "Open the fold icon(\u{1F7E1}\u{1F7E2})": "\u70B9\u51FB\u56FE\u6807(\u{1F7E1}\u{1F7E2})\u8FDB\u884C\u6298\u53E0",
  "zk-local-graph-view": "\u5C40\u90E8\u5173\u7CFB\u89C6\u56FE",
  "Open close-relative graph": "\u6253\u5F00\u90BB\u8FD1\u56FE",
  "Mermaid graph to display parent, siblings and sons": "\u663E\u793A\u5F53\u524D\u7B14\u8BB0\u7684\u7236\u8282\u70B9\uFF0C\u624B\u8DB3\u8282\u70B9\u548C\u5B50\u8282\u70B9",
  "Open inlinks graph": "\u6253\u5F00\u5165\u94FE\u56FE",
  "Mermaid graph to display inlinks": "\u663E\u793A\u5F53\u524D\u7B14\u8BB0\u53CA\u5176\u6240\u6709\u5165\u94FE",
  "Open outlinks graph": "\u6253\u5F00\u51FA\u94FE\u56FE",
  "Mermaid graph to display outlinks": "\u663E\u793A\u5F53\u524D\u7B14\u8BB0\u53CA\u5176\u6240\u6709\u51FA\u94FE",
  "Enter a number to set the height of graph in pixels.": "\u8F93\u5165\u4E00\u4E2A\u50CF\u7D20\u503C\u6765\u8BBE\u7F6E\u89C6\u56FE\u7684\u9AD8\u5EA6.",
  "all file extension": "\u68C0\u7D22\u6240\u6709\u7C7B\u578B\u51FA\u94FE",
  ".md only": "\u4EC5\u68C0\u7D22.md\u7C7B\u578B\u51FA\u94FE",
  "Index graph styles": "\u663E\u793A\u8BBE\u7F6E",
  "Height of close-relative graph": "\u90BB\u8FD1\u89C6\u56FE\u9AD8\u5EA6",
  "Height of inlinks graph": "\u5165\u94FE\u89C6\u56FE\u9AD8\u5EA6",
  "Height of outlinks graph": "\u51FA\u94FE\u89C6\u56FE\u9AD8\u5EA6",
  "direction of graph": "\u65B9\u5411",
  '"LR": feft to right': '"LR": \u4ECE\u5DE6\u5230\u53F3',
  '"RL": right to left': '"RL": \u4ECE\u53F3\u5230\u5DE6',
  '"TB": top to bottom': '"TB": \u4ECE\u4E0A\u5230\u4E0B',
  '"BT": bottom to top': '"BT": \u4ECE\u4E0B\u5230\u4E0A',
  "Detect file extensions": "\u9650\u5B9A\u51FA\u94FE\u7684\u6587\u4EF6\u7C7B\u578B",
  "Toolbar": "\u56FE\u6807\u547D\u4EE4\u680F",
  "Open the icons(commands) in the branch graph.": "\u6253\u5F00\u53F3\u4E0A\u89D2\u7684\u56FE\u6807\u547D\u4EE4\u680F",
  "Index button": "\u5173\u952E\u8BCD\u68C0\u7D22\u6309\u94AE",
  "Main Notes button": "\u4E3B\u7B14\u8BB0\u68C0\u7D22\u6309\u94AE",
  "Name of main note button": "\u6309\u94AE\u540D\u79F0",
  "Custom created time(optional)": "\u4E3B\u7B14\u8BB0\u521B\u5EFA\u65F6\u95F4\uFF08\u81EA\u5B9A\u4E49\u5B57\u6BB5\uFF09",
  "Specify a frontmatter field for time of note created time": "\u6307\u5B9A\u4E00\u4E2A\u5C5E\u6027\u540D\u79F0\u4F5C\u4E3A\u4E3B\u7B14\u8BB0\u7684\u521B\u5EFA\u65F6\u95F4",
  "History List": "\u68C0\u7D22\u8BB0\u5F55",
  "And set the list length": "\u8BBE\u7F6E\u6700\u5927\u6253\u5F00\u8BB0\u5F55\u6761\u6570",
  "list tree": "\u5927\u7EB2\u89C6\u56FE",
  "set default width and height for cards": "\u8BBE\u7F6E\u5361\u7247\u5BBD\u5EA6\u4E0E\u9AD8\u5EA6",
  "card width": "\u5361\u7247\u5BBD\u5EA6",
  "card height": "\u5361\u7247\u9AD8\u5EA6",
  "set the fixed path for exported canvas file": "\u26A0\u8BBE\u7F6E\u4E00\u4E2A\u56FA\u5B9A\u7684\u767D\u677F\u6587\u4EF6",
  "if empty, it will create a new canvas file every time": "\u5982\u679C\u4E0D\u8BBE\u7F6E\uFF0C\u6BCF\u6B21\u90FD\u4F1A\u4EA7\u751F\u4E00\u4E2A\u65B0\u7684\u767D\u677F\u6587\u4EF6",
  "Example: folder/filename.canvas": "\u6BD4\u5982: \u6587\u4EF6\u5939/\u6587\u4EF6\u540D.canvas",
  "siblings order": "\u624B\u8DB3\u8282\u70B9\uFF08\u540C\u7EA7\uFF09\u6392\u5E8F",
  "siblings order description": "\u5728\u540C\u7EA7\u8282\u70B9\u6392\u5E8F\u4E2D\uFF0C\u9009\u62E9\u4EE5ID\u4E2D\u7684\u6570\u5B57\u6216\u662F\u5B57\u6BCD\u4E3A\u66F4\u9AD8\u4F18\u5148\u7EA7",
  "number first": "\u6570\u5B57\u4F18\u5148",
  "letter first": "\u5B57\u6BCD\u4F18\u5148",
  "List length": "\u6700\u5927\u6761\u6570",
  "Maximum number of notes showing in Modal.": "\u8BBE\u7F6E\u5728\u5F39\u6846\u4E2D\u663E\u793A\u7684\u6700\u5927\u7B14\u8BB0\u6761\u6570.",
  "Node menu": "\u8282\u70B9\u547D\u4EE4\u83DC\u5355",
  "node_menu_des": "\u5728\u8282\u70B9\u4E0A\u53F3\u51FB\u9F20\u6807\u6253\u5F00\u547D\u4EE4\u83DC\u5355",
  "create node": "\u521B\u5EFA\u8282\u70B9",
  "specify a command name": "\u6307\u5B9A\u547D\u4EE4\u540D\u79F0",
  "delete node": "\u5220\u9664\u8282\u70B9",
  "custom command": "\u81EA\u9009\u547D\u4EE4",
  "Open command palette": "\u6253\u5F00\u547D\u4EE4\u9762\u677F",
  "experimental": "\u26A0\u5B9E\u9A8C\u6027\u529F\u80FD",
  "multiple IDs for main notes": "\u5141\u8BB8\u4E3B\u7B14\u8BB0\u6709\u591A\u4E2AID",
  "multiple IDs description": "\u901A\u8FC7\u7ED9\u4E3B\u7B14\u8BB0\u5206\u914D\u989D\u5916\u7684ID\u5C06\u5176\u6DFB\u52A0\u5230\u5176\u5B83\u5206\u652F",
  "Specify a frontmatter field(list) for multiple IDs": "\u6307\u5B9A\u4E00\u4E2A\u7C7B\u578B\u4E3A\u5217\u8868\u7684\u5C5E\u6027\u540D\u79F0\u6765\u5B58\u653E\u591A\u4E2AID",
  "auto-copy ID": "\u81EA\u52A8\u590D\u5236\u8282\u70B9\u7B14\u8BB0\u7F16\u53F7",
  "auto-copy-des": "\u81EA\u52A8\u590D\u5236\u8282\u70B9\u5BF9\u8C61 {id, path, created}",
  "same width for siblings": "\u8BBE\u7F6E\u624B\u8DB3\u8282\u70B9\u540C\u5BBD",
  "display created time": "\u663E\u793A\u521B\u5EFA\u65F6\u95F4\uFF08\u5F53\u5149\u6807\u60AC\u505C\u5728\u8282\u70B9\u94FE\u63A5\u65F6\uFF09",
  "created": "\u521B\u5EFA\u65F6\u95F4",
  "Add command": "\u6DFB\u52A0\u547D\u4EE4",
  "auto-copy: ": "\u81EA\u52A8\u590D\u5236: ",
  "file path": "\u6587\u4EF6\u8DEF\u5F84",
  "created time": "\u521B\u5EFA\u65F6\u95F4",
  "none": "\u4E0D\u590D\u5236",
  "play controller": "\u64AD\u653E\u63A7\u5236\u5668",
  "play_des": "\u6253\u5F00\u5E95\u90E8\u5C45\u4E2D\u7684\u64AD\u653E\u63A7\u5236\u5668",
  "Set color for nodes": "\u8BBE\u7F6E\u5206\u652F\u8282\u70B9\u989C\u8272",
  "Set datetime format": "\u8BBE\u7F6E\u65E5\u671F\u65F6\u95F4\u683C\u5F0F",
  "Shorten the distance between adjacent nodes": "\u7F29\u77ED\u90BB\u8FD1\u8282\u70B9\u7684\u8DDD\u79BB",
  "\u26A0Required restart to take effect": "\u26A0\u9700\u91CD\u65B0\u52A0\u8F7D\u624D\u80FD\u751F\u6548",
  "Branches uncrossing": "\u5206\u652F\u4E4B\u95F4\u4E0D\u4EA4\u53C9",
  "Display from : ": "\u8D77\u70B9\uFF1A",
  "To : ": "\u7EC8\u70B9\uFF1A",
  "Text : ": "\u6587\u672C\uFF1A",
  "parent": "\u7236\u8282\u70B9",
  "index": "\u7D22\u5F15\u70B9",
  "root": "\u6839\u8282\u70B9",
  "next": "\u5411\u4E0B\u4E00\u5C42",
  "end": "\u6700\u540E\u4E00\u5C42",
  "id": "ID",
  "title": "\u6587\u5B57\u6807\u9898",
  "both": "ID+\u6807\u9898",
  "Current index: ": "\u5F53\u524D\u5173\u952E\u8BCD:",
  "random index": "\u968F\u673A\u5173\u952E\u8BCD",
  "random main note": "\u968F\u673A\u4E3B\u7B14\u8BB0",
  "\u274CSetting error: no folder or tag specified for main notes!": "\u274C\u8BBE\u7F6E\u9519\u8BEF: \u6CA1\u6709\u4E3A\u4E3B\u7B14\u8BB0\u6307\u5B9A\u6587\u4EF6\u5939\u6216\u6807\u7B7E!",
  "\u274CSetting error: no folder specified for index!": "\u274C\u8BBE\u7F6E\u9519\u8BEF: \u6CA1\u6709\u4E3A\u5173\u952E\u8BCD\u6307\u5B9A\u6587\u4EF6\u5939!",
  "Index: ": "\u5173\u952E\u8BCD: ",
  "has no valid main note outlinks": "\u6CA1\u6709\u5305\u542B\u6709\u6548\u4E3B\u7B14\u8BB0\u94FE\u63A5",
  "table view": "\u8868\u683C\u89C6\u56FE",
  "Current note: ": "\u5F53\u524D\u4E3B\u7B14\u8BB0: ",
  "settings": "\u6253\u5F00\u8BBE\u7F6E",
  "export to canvas": "\u5BFC\u51FA\u5230\u767D\u677F",
  "select a main note": "\u9009\u62E9\u4E00\u4E2A\u4E3B\u7B14\u8BB0",
  "select an index": "\u9009\u62E9\u4E00\u4E2A\u5173\u952E\u8BCD",
  "all trees": "\u6240\u6709\u6811",
  "growing animation": "\u64AD\u653E\u5206\u652F\u751F\u957F\u52A8\u753B",
  "structure": "\u7ED3\u6784\u56FE",
  "roadmap": "\u8DEF\u7EBF\u56FE",
  "style : ": "\u98CE\u683C: ",
  "playPrevious": "\u5411\u540E",
  "playNext": "\u5411\u524D",
  "fullscreen": "\u5168\u5C4F",
  "close relative": "\u90BB\u8FD1",
  "inlinks": "\u5165\u94FE",
  "outlinks": "\u51FA\u94FE",
  "expand graph": "\u653E\u5927\u663E\u793A",
  "open zk-index-graph": "\u6253\u5F00\u5206\u652F\u89C6\u56FE",
  "open zk-local-graph": "\u6253\u5F00\u5C40\u90E8\u5173\u7CFB\u89C6\u56FE",
  "zk-index-graph": "\u5206\u652F\u89C6\u56FE",
  "zk-local-graph": "\u5C40\u90E8\u5173\u7CFB\u89C6\u56FE",
  "Main notes": "\u{1F4C4}\u4E3B\u7B14\u8BB0",
  "\u{1F4D6}index": "\u{1F4D6}\u5173\u952E\u8BCD",
  "Copy zk-navigation URI": "\u590D\u5236 zk-navigation \u94FE\u63A5",
  "reveal current file in zk-index-graph": "\u5728\u5206\u652F\u89C6\u56FE\u663E\u793A\u5F53\u524D\u6587\u4EF6",
  "Index folder not set!": "\u274C\u8BBE\u7F6E\u9519\u8BEF: \u5173\u952E\u8BCD\u6587\u4EF6\u5939\u6CA1\u6709\u8BBE\u7F6E!",
  "No index can be found by path": "\u6307\u5B9A\u6587\u4EF6\u5939\u627E\u4E0D\u5230\u4EFB\u4F55\u5173\u952E\u8BCD\uFF1A",
  "note's ID": "\u7B14\u8BB0\u7F16\u53F7(ID)",
  "note's title": "\u7B14\u8BB0\u6807\u9898",
  "Time of creation": "\u521B\u5EFA\u65F6\u95F4",
  "Copy markdown table": "\u590D\u5236 markdown \u8868\u683C",
  "choose a command to add": "\u9009\u62E9\u4E00\u4E2A\u547D\u4EE4\u5E76\u6DFB\u52A0",
  "to navigate": "\u5BFC\u822A",
  "to choose an icon": "\u9009\u4E2D\u4E00\u4E2A\u56FE\u6807",
  "to cancel": "\u53D6\u6D88",
  "Use a custom name": "\u4F7F\u7528\u4E00\u4E2A\u81EA\u5B9A\u4E49\u540D\u79F0",
  "Save": "\u4FDD\u5B58",
  "Choose a custom Name for your new Command": "\u4E3A\u4F60\u7684\u547D\u4EE4\u6DFB\u52A0\u4E00\u4E2A\u81EA\u5B9A\u4E49\u540D\u79F0",
  "to save": "\u4FDD\u5B58",
  "Choose a Icon for your new Command": "\u4E3A\u4F60\u7684\u547D\u4EE4\u6DFB\u52A0\u4E00\u4E2A\u56FE\u6807",
  "to choose a custom icon": "\u9009\u62E9\u4E00\u4E2A\u56FE\u6807"
};

// src/lang/locale/en.ts
var en_default = {
  "ZK main notes": "Main notes",
  "Main notes folder location": "\u26A0Main notes folder location",
  "Specify a folder location to identify main notes": "Specify a folder location to identify main notes",
  "Example: folder1/folder2": "Example: folder1/folder2",
  "Main notes tag": "Main notes tag",
  "Specify a tag to identify main notes": "Specify a tag to identify main notes(optional)",
  "Note ID field options": "\u26A0Note ID field options",
  "Option 1: Filename is note ID": "Option 1: Filename is note ID",
  "Option 2: Metadata is note ID": "Option 2: Metadata is note ID",
  "Option 3: Prefix of filename is note ID": "Option 3: Prefix of filename is note ID",
  "Specify a frontmatter field for note's title": "\u26A0Specify a file property for note's title",
  "Specify a frontmatter field for note's ID": "\u26A0Specify a file property for note's ID",
  "Specify a separator between ID and title": "\u26A0Specify a separator between ID and title",
  '" "(blank)': '" "(blank)',
  '"-"(hyphen)': '"-"(hyphen)',
  '"_"(underscore)': '"_"(underscore)',
  "Retrieval": "Retrieval",
  "Indexes folder location": "\u26A0Keyword files folder location",
  "index_description": "A vaild keyword index file is a .md file includes a few main note links",
  "zk-index-graph-view": "zk-index-graph-view",
  "Name of index button": "Button name",
  "Suggest mode of index modal": "Suggest mode of keyword modal",
  "Suggest mode of main note modal": "Suggest mode of main note modal",
  "Keyword Order": "keyword Order",
  "Fuzzy Suggest": "Fuzzy Suggest",
  "ID Order": "ID/Title Order",
  "Set red dash line for nodes with ID ends with letter": "Set red dash line for nodes with ID ends with letter",
  "In order to distinguish nodes which ID ends with letter and number": "In order to distinguish nodes which ID ends with letter or number",
  "Fold node toggle": "Fold node toggle",
  "Open the fold icon(\u{1F7E1}\u{1F7E2})": "Open the fold icon(\u{1F7E1}\u{1F7E2})",
  "zk-local-graph-view": "zk-local-graph-view",
  "Open close-relative graph": "Open close-relative graph",
  "Mermaid graph to display parent, siblings and sons": "Mermaid graph to display parent, siblings and children",
  "Open inlinks graph": "Open inlinks graph",
  "Mermaid graph to display inlinks": "Mermaid graph to display inlinks",
  "Open outlinks graph": "Open outlinks graph",
  "Mermaid graph to display outlinks": "Mermaid graph to display outlinks",
  "Enter a number to set the height of graph in pixels.": "Enter a number to set the height of graph in pixels.",
  "all file extension": "all file extension",
  ".md only": ".md only",
  "Index graph styles": "Index graph styles",
  "Height of close-relative graph": "Height of close-relative graph",
  "Height of inlinks graph": "Height of inlinks graph",
  "Height of outlinks graph": "Height of outlinks graph",
  "direction of branch graph": "direction of branch graph",
  '"LR": feft to right': '"LR": feft to right',
  '"RL": right to left': '"RL": right to left',
  '"TB": top to bottom': '"TB": top to bottom',
  '"BT": bottom to top': '"BT": bottom to top',
  "direction of graph": "direction of graph",
  "Detect file extensions": "Detect file extensions",
  "Toolbar": "Icon toolbar",
  "Open the icons(commands) in the branch graph.": "Open the icons(commands) on the index graph view.",
  "Index button": "Keyword button",
  "Main Notes button": "Main notes button",
  "Name of main note button": "Button name",
  "Custom created time(optional)": "Custom created time(used in table view and animation)",
  "Specify a frontmatter field for time of note created time": "Specify a file property for the time of main note creation",
  "History List": "recent retrieval",
  "And set the list length": "Set the max length",
  "list tree": "outline view",
  "set default width and height for cards": "set default width and height for cards",
  "card width": "card width",
  "card height": "card height",
  "set the fixed path for exported canvas file": "\u26A0set a fixed canvas file",
  "if empty, it will create a new canvas file every time": "if not set, it will create a new canvas file every time",
  "Example: folder/filename.canvas": "Example: folder/filename.canvas",
  "siblings order": "siblings ordering",
  "siblings order description": "\u3010number first\u3011: 1->2...->a->b;\u3010letter first\u3011: a->b...->1->2",
  "number first": "number first",
  "letter first": "letter first",
  "List length": "List length",
  "Maximum number of notes showing in Modal.": "Maximum number of notes showing in Modal.",
  "Node menu": "Node menu",
  "node_menu_des": "Right click to open the menu",
  "create node": "create node",
  "specify a command name": "specify a command name",
  "delete node": "delete node",
  "custom command": "custom command",
  "Open command palette": "Open command palette",
  "experimental": "\u26A0experimental",
  "multiple IDs for main notes": "Allow multiple IDs for main notes",
  "multiple IDs description": "You can add a main note into other branches by assigning additional IDs",
  "Specify a frontmatter field(list) for multiple IDs": "Specify a file property(list) for storing multiple IDs",
  "auto-copy ID": "auto-copy ID",
  "auto-copy-des": "auto-copy {id, path, created}",
  "same width for siblings": "Set same width for siblings",
  "display created time": "display created time when mouseenter",
  "created": "created",
  "Add command": "Add command",
  "auto-copy: ": "auto-copy: ",
  "file path": "file path",
  "created time": "created time",
  "none": "none",
  "play controller": "Play controller",
  "play_des": "open the play controller",
  "Set color for nodes": "Set color for branch's nodes",
  "Set datetime format": "Set datetime format",
  "Shorten the distance between adjacent nodes": "Shorten the distance between adjacent nodes",
  "\u26A0Required restart to take effect": "\u26A0Required restart to take effect",
  "Branches uncrossing": "Branches uncrossing",
  "Display from : ": "From : ",
  "To : ": "To : ",
  "Text : ": "Text : ",
  "parent": "parent",
  "index": "index",
  "root": "root",
  "next": "next",
  "end": "end",
  "id": "id",
  "title": "title",
  "both": "both",
  "Current index: ": "Index:",
  "random index": "random keyword",
  "random main note": "random main note",
  "\u274CSetting error: no folder or tag specified for main notes!": "\u274CSetting error: no folder or tag specified for main notes!",
  "\u274CSetting error: no folder specified for index!": "\u274CSetting error: no folder specified for index!",
  "Index: ": "Index: ",
  "has no valid main note outlinks": "has no valid main note outlinks",
  "table view": "table view",
  "Current note: ": "Index: ",
  "settings": "open settings",
  "export to canvas": "export to canvas",
  "select a main note": "select a main note",
  "select an index": "select a keyword",
  "all trees": "all trees",
  "growing animation": "start timelapse animation",
  "structure": "structure",
  "roadmap": "roadmap",
  "style : ": "style : ",
  "playPrevious": "previous",
  "playNext": "playNext",
  "fullscreen": "fullscreen",
  "close relative": "close relative",
  "inlinks": "inlinks",
  "outlinks": "outlinks",
  "expand graph": "expand graph",
  "open zk-index-graph": "open zk-index-graph",
  "open zk-local-graph": "open zk-local-graph",
  "zk-local-graph": "zk-local-graph",
  "zk-index-graph": "zk-index-graph",
  "Main notes": "\u{1F4C4}Main notes",
  "\u{1F4D6}index": "\u{1F4D6}keywords",
  "Copy zk-navigation URI": "Copy zk-navigation URI",
  "reveal current file in zk-index-graph": "reveal current file in zk-index-graph",
  "Index folder not set!": "\u274CSetting error: Index folder not set!",
  "No index can be found by path": "No index can be found by path",
  "note's ID": "note's ID",
  "note's title": "note's title",
  "Time of creation": "Time of creation",
  "Copy markdown table": "Copy markdown table",
  "choose a command to add": "choose a command to add",
  "to navigate": "to navigate",
  "to choose an icon": "to choose an icon",
  "to cancel": "to cancel",
  "Use a custom name": "Use a custom name",
  "Save": "Save",
  "Choose a custom Name for your new Command": "Choose a custom Name for your new Command",
  "to save": "to save",
  "Choose a Icon for your new Command": "Choose a Icon for your new Command",
  "to choose a custom icon": "to choose a custom icon"
};

// src/lang/helper.ts
var localeMap = {
  en: en_default,
  zh: zh_default
};
var lang = window.localStorage.getItem("language");
var locale = localeMap[lang || "en"];
function t(text) {
  return locale && locale[text] || en_default[text];
}

// src/settings/settings.ts
var import_obsidian7 = require("obsidian");

// src/suggester/FolderSuggester.ts
var import_obsidian = require("obsidian");
var FolderSuggest = class extends import_obsidian.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    let folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggester/TagSuggester.ts
var import_obsidian2 = require("obsidian");
var TagSuggest = class extends import_obsidian2.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    const allTags = Object.keys(this.app.metadataCache.getTags());
    let tags = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    allTags.forEach((tag) => {
      if (tag.toLowerCase().contains(lowerCaseInputStr)) {
        tags.push(tag);
      }
    });
    return tags;
  }
  renderSuggestion(tag, el) {
    el.setText(tag);
  }
  selectSuggestion(tag) {
    this.inputEl.value = tag;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggester/FileSuggester.ts
var import_obsidian3 = require("obsidian");
var FileSuggest = class extends import_obsidian3.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles().filter((f) => f.path.endsWith(".canvas"));
    const files = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((file) => {
      if (file instanceof import_obsidian3.TFile && file.path.toLowerCase().contains(lowerCaseInputStr)) {
        files.push(file);
      }
    });
    return files;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/modal/addCommandModal.ts
var import_obsidian4 = require("obsidian");
var addCommandModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.commands = Object.values(app.commands.commands);
    this.setPlaceholder(t("choose a command to add"));
    this.setInstructions([
      {
        command: "\u2191\u2193",
        purpose: t("to navigate")
      },
      {
        command: "\u21B5",
        purpose: t("to choose an icon")
      },
      {
        command: "esc",
        purpose: t("to cancel")
      }
    ]);
  }
  async awaitSelection() {
    this.open();
    return new Promise((resolve, reject) => {
      this.onChooseItem = (item) => resolve(item);
      this.onClose = () => window.setTimeout(() => reject("No Command selected"), 0);
    });
  }
  renderSuggestion(item, el) {
    el.addClass("mod-complex");
    const content = el.createDiv({ cls: "suggestion-content" });
    content.createDiv({ cls: "suggestion-title" }).setText(item.item.name);
    if (item.item.icon) {
      const aux = el.createDiv({ cls: "suggestion-aux" });
      (0, import_obsidian4.setIcon)(aux.createSpan({ cls: "suggestion-flair" }), item.item.icon);
    }
  }
  getItems() {
    return this.commands;
  }
  getItemText(item) {
    return item.name;
  }
  onChooseItem(item, evt) {
  }
};

// src/modal/chooseIconModal.ts
var import_obsidian5 = require("obsidian");
var ChooseIconModal = class extends import_obsidian5.FuzzySuggestModal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.setPlaceholder(t("Choose a Icon for your new Command"));
    this.setInstructions([
      {
        command: "\u2191\u2193",
        purpose: t("to navigate")
      },
      {
        command: "\u21B5",
        purpose: t("to choose a custom icon")
      },
      {
        command: "esc",
        purpose: t("to cancel")
      }
    ]);
  }
  async awaitSelection() {
    this.open();
    return new Promise((resolve, reject) => {
      this.onChooseItem = (item) => resolve(item);
      this.onClose = () => window.setTimeout(() => reject("No Icon selected"), 0);
    });
  }
  renderSuggestion(item, el) {
    el.addClass("mod-complex");
    const content = el.createDiv({ cls: "suggestion-content" });
    content.createDiv({ cls: "suggestion-title" }).setText(item.item.replace(/-/g, " ").replace(/(^\w{1})|(\s+\w{1})/g, (letter) => letter.toUpperCase()));
    const aux = el.createDiv({ cls: "suggestion-aux" });
    (0, import_obsidian5.setIcon)(aux.createSpan({ cls: "suggestion-flair" }), item.item);
  }
  getItems() {
    let iconIds = (0, import_obsidian5.getIconIds)().map((iconId) => iconId.replace(/^lucide-/, ""));
    return iconIds;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(_, __) {
  }
};

// src/modal/chooseCustomNameModal.ts
var import_obsidian6 = require("obsidian");
var chooseCustomNameModal = class extends import_obsidian6.SuggestModal {
  constructor(app, defaultName) {
    super(app);
    this.defaultName = defaultName;
    this.setPlaceholder(t("Use a custom name"));
    this.resultContainerEl.style.display = "none";
    this.setInstructions([
      {
        command: "",
        purpose: t("Choose a custom Name for your new Command")
      },
      {
        command: "\u21B5",
        purpose: t("to save")
      },
      {
        command: "esc",
        purpose: t("to cancel")
      }
    ]);
  }
  onOpen() {
    var _a;
    super.onOpen();
    this.inputEl.value = this.defaultName;
    const wrapper = createDiv({ cls: "zk-name-input-wrapper" });
    (_a = this.inputEl.parentNode) == null ? void 0 : _a.insertBefore(wrapper, this.inputEl);
    wrapper.appendChild(this.inputEl);
    wrapper.parentElement.style.display = "block";
    const btn = createEl("button", { text: t("Save"), cls: "mod-cta" });
    btn.onclick = (e) => this.selectSuggestion(this.inputEl.value, e);
    wrapper.appendChild(btn);
  }
  async awaitSelection() {
    this.open();
    return new Promise((resolve, reject) => {
      this.onChooseSuggestion = (item) => resolve(item);
      this.onClose = () => window.setTimeout(() => reject("No Name selected"), 0);
    });
  }
  getSuggestions(query) {
    return [query];
  }
  renderSuggestion(value, el) {
  }
  onChooseSuggestion(item, evt) {
  }
};

// src/settings/settings.ts
var ZKNavigationSettngTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Zettelkasten Navigation" });
    const settingTabDiv = containerEl.createDiv("zk-setting-tab");
    const topButtonsDiv = settingTabDiv.createDiv("top-buttons-div");
    const mainNoteButton = new import_obsidian7.ButtonComponent(topButtonsDiv);
    mainNoteButton.setButtonText(t("ZK main notes")).setClass("vertical-tab-nav-item").onClick(() => {
      this.openTabSection(0, topButtonsDiv);
    });
    const retrievalButton = new import_obsidian7.ButtonComponent(topButtonsDiv);
    retrievalButton.setButtonText(t("Retrieval")).setClass("vertical-tab-nav-item").onClick(() => {
      this.openTabSection(1, topButtonsDiv);
    });
    const indexGraphButton = new import_obsidian7.ButtonComponent(topButtonsDiv);
    indexGraphButton.setButtonText(t("zk-index-graph-view")).setClass("vertical-tab-nav-item").onClick(() => {
      this.openTabSection(2, topButtonsDiv);
    });
    const localGraphButton = new import_obsidian7.ButtonComponent(topButtonsDiv);
    localGraphButton.setButtonText(t("zk-local-graph-view")).setClass("vertical-tab-nav-item").onClick(() => {
      this.openTabSection(3, topButtonsDiv);
    });
    const experimentalButton = new import_obsidian7.ButtonComponent(topButtonsDiv);
    experimentalButton.setButtonText(t("experimental")).setClass("vertical-tab-nav-item").onClick(() => {
      this.openTabSection(4, topButtonsDiv);
    });
    const mainNotesDiv = settingTabDiv.createDiv("zk-setting-section");
    new import_obsidian7.Setting(mainNotesDiv).setName(t("Main notes folder location")).setDesc(t("Specify a folder location to identify main notes")).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(t("Example: folder1/folder2")).setValue(this.plugin.settings.FolderOfMainNotes).onChange((value) => {
        this.plugin.settings.FolderOfMainNotes = value;
        this.plugin.RefreshIndexViewFlag = true;
      });
    });
    new import_obsidian7.Setting(mainNotesDiv).setName(t("Main notes tag")).setDesc(t("Specify a tag to identify main notes")).addSearch((cb) => {
      new TagSuggest(this.app, cb.inputEl);
      cb.setValue(this.plugin.settings.TagOfMainNotes).onChange((value) => {
        this.plugin.settings.TagOfMainNotes = value;
        this.plugin.RefreshIndexViewFlag = true;
      });
    });
    const IDOption = new import_obsidian7.Setting(mainNotesDiv).setName(t("Note ID field options")).addDropdown((options) => options.addOption("1", t("Option 1: Filename is note ID")).addOption("2", t("Option 2: Metadata is note ID")).addOption("3", t("Option 3: Prefix of filename is note ID")).setValue(this.plugin.settings.IDFieldOption).onChange((value) => {
      this.plugin.settings.IDFieldOption = value;
      this.plugin.RefreshIndexViewFlag = true;
      this.display();
    }));
    switch (this.plugin.settings.IDFieldOption) {
      case "1":
        new import_obsidian7.Setting(mainNotesDiv).setName(t("Specify a frontmatter field for note's title")).addText((cb) => cb.setValue(this.plugin.settings.TitleField).onChange((value) => {
          this.plugin.settings.TitleField = value;
          this.plugin.RefreshIndexViewFlag = true;
        }));
        break;
      case "2":
        new import_obsidian7.Setting(mainNotesDiv).setName(t("Specify a frontmatter field for note's ID")).addText((cb) => cb.setValue(this.plugin.settings.IDField).onChange((value) => {
          this.plugin.settings.IDField = value;
          this.plugin.RefreshIndexViewFlag = true;
        }));
        break;
      case "3":
        new import_obsidian7.Setting(mainNotesDiv).setName(t("Specify a separator between ID and title")).addDropdown((options) => options.addOption(" ", t('" "(blank)')).addOption("-", t('"-"(hyphen)')).addOption("_", t('"_"(underscore)')).setValue(this.plugin.settings.Separator).onChange((value) => {
          this.plugin.settings.Separator = value;
          this.plugin.RefreshIndexViewFlag = true;
        }));
        break;
      default:
    }
    new import_obsidian7.Setting(mainNotesDiv).setName(t("Custom created time(optional)")).setDesc(t("Specify a frontmatter field for time of note created time")).addText((cb) => cb.setValue(this.plugin.settings.CustomCreatedTime).onChange((value) => {
      this.plugin.settings.CustomCreatedTime = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    const retrievalDiv = settingTabDiv.createDiv("zk-setting-section");
    new import_obsidian7.Setting(retrievalDiv).setName(t("Main Notes button")).addToggle((toggle) => toggle.setValue(this.plugin.settings.MainNoteButton).onChange((value) => {
      this.plugin.settings.MainNoteButton = value;
      this.plugin.RefreshIndexViewFlag = true;
      this.display();
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(MainNoteButtonDiv);
      });
    });
    const MainNoteButtonDiv = retrievalDiv.createDiv("zk-local-section zk-hidden");
    new import_obsidian7.Setting(MainNoteButtonDiv).setName(t("Name of main note button")).addText((cb) => cb.setValue(this.plugin.settings.MainNoteButtonText).onChange((value) => {
      this.plugin.settings.MainNoteButtonText = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(MainNoteButtonDiv).setName(t("Suggest mode of main note modal")).addDropdown((options) => options.addOption("IDOrder", t("ID Order")).addOption("fuzzySuggest", t("Fuzzy Suggest")).setValue(this.plugin.settings.MainNoteSuggestMode).onChange((value) => {
      this.plugin.settings.MainNoteSuggestMode = value;
    }));
    new import_obsidian7.Setting(MainNoteButtonDiv).setName(t("List length")).setDesc(t("Maximum number of notes showing in Modal.")).addText((cb) => {
      cb.inputEl.placeholder = "100(defaulf)";
      cb.setValue(this.plugin.settings.maxLenMainModel.toString()).onChange((value) => {
        if (/^[1-9]\d*$/.test(value)) {
          this.plugin.settings.maxLenMainModel = Number(value);
        } else {
          this.plugin.settings.maxLenMainModel = 100;
        }
      });
    });
    new import_obsidian7.Setting(retrievalDiv).setName(t("Index button")).addToggle((toggle) => toggle.setValue(this.plugin.settings.IndexButton).onChange((value) => {
      this.plugin.settings.IndexButton = value;
      this.plugin.RefreshIndexViewFlag = true;
      this.display();
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(indexButtonDiv);
      });
    });
    const indexButtonDiv = retrievalDiv.createDiv("zk-local-section zk-hidden");
    new import_obsidian7.Setting(indexButtonDiv).setName(t("Indexes folder location")).setDesc(t("index_description")).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(t("Example: folder1/folder2")).setValue(this.plugin.settings.FolderOfIndexes).onChange((value) => {
        this.plugin.settings.FolderOfIndexes = value;
        this.plugin.RefreshIndexViewFlag = true;
      });
    });
    new import_obsidian7.Setting(indexButtonDiv).setName(t("Name of index button")).addText((cb) => cb.setValue(this.plugin.settings.IndexButtonText).onChange((value) => {
      this.plugin.settings.IndexButtonText = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(indexButtonDiv).setName(t("Suggest mode of index modal")).addDropdown((options) => options.addOption("keywordOrder", t("Keyword Order")).addOption("fuzzySuggest", t("Fuzzy Suggest")).setValue(this.plugin.settings.SuggestMode).onChange((value) => {
      this.plugin.settings.SuggestMode = value;
    }));
    new import_obsidian7.Setting(indexButtonDiv).setName(t("List length")).setDesc(t("Maximum number of notes showing in Modal.")).addText((cb) => {
      cb.inputEl.placeholder = "100(defaulf)";
      cb.setValue(this.plugin.settings.maxLenIndexModel.toString()).onChange((value) => {
        if (/^[1-9]\d*$/.test(value)) {
          this.plugin.settings.maxLenIndexModel = Number(value);
        } else {
          this.plugin.settings.maxLenIndexModel = 100;
        }
      });
    });
    const indexGraphView = settingTabDiv.createDiv("zk-setting-section");
    new import_obsidian7.Setting(indexGraphView).setName(t("Index graph styles")).addDropdown((options) => options.addOption("structure", t("structure")).addOption("roadmap", t("roadmap")).setValue(this.plugin.settings.graphType).onChange((value) => {
      this.plugin.settings.graphType = value;
      this.plugin.RefreshIndexViewFlag = true;
      structureSettingDiv.addClass("zk-hidden");
      roadmapSettingDiv.addClass("zk-hidden");
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        if (this.plugin.settings.graphType === "structure") {
          this.hideDiv(structureSettingDiv);
        } else if (this.plugin.settings.graphType === "roadmap") {
          this.hideDiv(roadmapSettingDiv);
        }
      });
    });
    const roadmapSettingDiv = indexGraphView.createDiv("zk-local-section zk-hidden");
    new import_obsidian7.Setting(roadmapSettingDiv).setName(t("Shorten the distance between adjacent nodes")).setDesc(t("\u26A0Required restart to take effect")).addToggle((toggle) => toggle.setValue(this.plugin.settings.nodeClose).onChange((value) => {
      this.plugin.settings.nodeClose = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(roadmapSettingDiv).setName(t("Branches uncrossing")).addToggle((toggle) => toggle.setValue(this.plugin.settings.gitUncrossing).onChange((value) => {
      this.plugin.settings.gitUncrossing = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    const structureSettingDiv = indexGraphView.createDiv("zk-local-section zk-hidden");
    new import_obsidian7.Setting(structureSettingDiv).setName(t("direction of graph")).addDropdown((options) => options.addOption("LR", t('"LR": feft to right')).addOption("RL", t('"RL": right to left')).addOption("TB", t('"TB": top to bottom')).addOption("BT", t('"BT": bottom to top')).setValue(this.plugin.settings.DirectionOfBranchGraph).onChange((value) => {
      this.plugin.settings.DirectionOfBranchGraph = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(structureSettingDiv).setName(t("siblings order")).setDesc(t("siblings order description")).addDropdown((options) => options.addOption("number", t("number first")).addOption("letter", t("letter first")).setValue(this.plugin.settings.siblingsOrder).onChange((value) => {
      this.plugin.settings.siblingsOrder = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(structureSettingDiv).setName(t("same width for siblings")).addToggle((toggle) => toggle.setValue(this.plugin.settings.siblingLenToggle).onChange((value) => {
      this.plugin.settings.siblingLenToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(structureSettingDiv).setName(t("Set red dash line for nodes with ID ends with letter")).setDesc(t("In order to distinguish nodes which ID ends with letter and number")).addToggle((toggle) => toggle.setValue(this.plugin.settings.RedDashLine).onChange((value) => {
      this.plugin.settings.RedDashLine = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(structureSettingDiv).setName(t("display created time")).setDesc(t("Set datetime format")).addText((cb) => {
      cb.inputEl.placeholder = "yyyy-MM-DD HH:mm";
      cb.setValue(this.plugin.settings.datetimeFormat).onChange((value) => {
        if (value === "") {
          this.plugin.settings.datetimeFormat = "yyyy-MM-DD HH:mm";
        } else {
          this.plugin.settings.datetimeFormat = value;
          this.plugin.RefreshIndexViewFlag = true;
        }
      });
    }).addToggle((toggle) => toggle.setValue(this.plugin.settings.displayTimeToggle).onChange((value) => {
      this.plugin.settings.displayTimeToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(structureSettingDiv).setName(t("Fold node toggle")).setDesc(t("Open the fold icon(\u{1F7E1}\u{1F7E2})")).addToggle((toggle) => toggle.setValue(this.plugin.settings.FoldToggle).onChange((value) => {
      this.plugin.settings.FoldToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(structureSettingDiv).setName(t("Set color for nodes")).addColorPicker((color) => color.setValue(this.plugin.settings.nodeColor).onChange((value) => {
      this.plugin.settings.nodeColor = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(indexGraphView).setName(t("Toolbar")).setDesc(t("Open the icons(commands) in the branch graph.")).addToggle((toggle) => toggle.setValue(this.plugin.settings.BranchToolbra).onChange((value) => {
      this.plugin.settings.BranchToolbra = value;
      this.plugin.RefreshIndexViewFlag = true;
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(branchToolbarDiv);
      });
    });
    const branchToolbarDiv = indexGraphView.createDiv("zk-local-section zk-hidden");
    new import_obsidian7.Setting(branchToolbarDiv).setName(t("settings")).then((setting) => {
      const parentEl = setting.settingEl.parentElement;
      if (parentEl) {
        parentEl.insertBefore(createDiv(), setting.settingEl);
      }
      const iconEl = createDiv();
      setting.settingEl.prepend(iconEl);
      (0, import_obsidian7.setIcon)(iconEl, "settings");
    }).addToggle((toggle) => toggle.setValue(this.plugin.settings.settingIcon).onChange((value) => {
      this.plugin.settings.settingIcon = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(branchToolbarDiv).setName(t("export to canvas")).then((setting) => {
      const parentEl = setting.settingEl.parentElement;
      if (parentEl) {
        parentEl.insertBefore(createDiv(), setting.settingEl);
      }
      const iconEl = createDiv();
      setting.settingEl.prepend(iconEl);
      (0, import_obsidian7.setIcon)(iconEl, "layout-dashboard");
    }).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(canvasAdditionSection);
      });
    }).addToggle((toggle) => toggle.setValue(this.plugin.settings.exportCanvas).onChange((value) => {
      this.plugin.settings.exportCanvas = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    const canvasAdditionSection = branchToolbarDiv.createDiv("zk-local-section zk-hidden");
    new import_obsidian7.Setting(canvasAdditionSection).setName(t("set the fixed path for exported canvas file")).setDesc(t("if empty, it will create a new canvas file every time")).addSearch((cb) => {
      new FileSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(t("Example: folder/filename.canvas")).setValue(this.plugin.settings.canvasFilePath).onChange((value) => {
        if (value.endsWith(".canvas")) {
          this.plugin.settings.canvasFilePath = value;
        } else {
          this.plugin.settings.canvasFilePath = "";
        }
      });
    });
    new import_obsidian7.Setting(canvasAdditionSection).setName(t("set default width and height for cards")).addText((cb) => {
      cb.inputEl.placeholder = t("card width");
      cb.setValue(this.plugin.settings.cardWidth.toString()).onChange((value) => {
        if (/^[1-9]\d*$/.test(value)) {
          this.plugin.settings.cardWidth = Number(value);
        } else {
          this.plugin.settings.cardWidth = 400;
        }
      });
    }).addText((cb) => {
      cb.inputEl.placeholder = t("card height");
      cb.setValue(this.plugin.settings.cardHeight.toString()).onChange((value) => {
        if (/^[1-9]\d*$/.test(value)) {
          this.plugin.settings.cardHeight = Number(value);
        } else {
          this.plugin.settings.cardHeight = 240;
        }
      });
    });
    if (this.plugin.settings.MainNoteButton == true) {
      new import_obsidian7.Setting(branchToolbarDiv).setName(t("random main note")).then((setting) => {
        const parentEl = setting.settingEl.parentElement;
        if (parentEl) {
          parentEl.insertBefore(createDiv(), setting.settingEl);
        }
        const iconEl = createDiv();
        setting.settingEl.prepend(iconEl);
        (0, import_obsidian7.setIcon)(iconEl, "dice-3");
      }).addToggle((toggle) => toggle.setValue(this.plugin.settings.RandomMainNote).onChange((value) => {
        this.plugin.settings.RandomMainNote = value;
        this.plugin.RefreshIndexViewFlag = true;
      }));
    }
    if (this.plugin.settings.IndexButton == true) {
      new import_obsidian7.Setting(branchToolbarDiv).setName(t("random index")).then((setting) => {
        const parentEl = setting.settingEl.parentElement;
        if (parentEl) {
          parentEl.insertBefore(createDiv(), setting.settingEl);
        }
        const iconEl = createDiv();
        setting.settingEl.prepend(iconEl);
        (0, import_obsidian7.setIcon)(iconEl, "dices");
      }).addToggle((toggle) => toggle.setValue(this.plugin.settings.RandomIndex).onChange((value) => {
        this.plugin.settings.RandomIndex = value;
        this.plugin.RefreshIndexViewFlag = true;
      }));
    }
    new import_obsidian7.Setting(branchToolbarDiv).setName(t("all trees")).then((setting) => {
      const parentEl = setting.settingEl.parentElement;
      if (parentEl) {
        parentEl.insertBefore(createDiv(), setting.settingEl);
      }
      const iconEl = createDiv();
      setting.settingEl.prepend(iconEl);
      (0, import_obsidian7.setIcon)(iconEl, "trees");
    }).addToggle((toggle) => toggle.setValue(this.plugin.settings.showAllToggle).onChange((value) => {
      this.plugin.settings.showAllToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(branchToolbarDiv).setName(t("table view")).then((setting) => {
      const parentEl = setting.settingEl.parentElement;
      if (parentEl) {
        parentEl.insertBefore(createDiv(), setting.settingEl);
      }
      const iconEl = createDiv();
      setting.settingEl.prepend(iconEl);
      (0, import_obsidian7.setIcon)(iconEl, "table");
    }).addToggle((toggle) => toggle.setValue(this.plugin.settings.TableView).onChange((value) => {
      this.plugin.settings.TableView = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(branchToolbarDiv).setName(t("list tree")).then((setting) => {
      const parentEl = setting.settingEl.parentElement;
      if (parentEl) {
        parentEl.insertBefore(createDiv(), setting.settingEl);
      }
      const iconEl = createDiv();
      setting.settingEl.prepend(iconEl);
      (0, import_obsidian7.setIcon)(iconEl, "list-tree");
    }).addToggle((toggle) => toggle.setValue(this.plugin.settings.ListTree).onChange((value) => {
      this.plugin.settings.ListTree = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(branchToolbarDiv).setName(t("History List")).then((setting) => {
      const parentEl = setting.settingEl.parentElement;
      if (parentEl) {
        parentEl.insertBefore(createDiv(), setting.settingEl);
      }
      const iconEl = createDiv();
      setting.settingEl.prepend(iconEl);
      (0, import_obsidian7.setIcon)(iconEl, "history");
    }).setDesc(t("And set the list length")).addSlider((cb) => {
      cb.setLimits(10, 50, 5).setValue(this.plugin.settings.HistoryMaxCount).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.HistoryMaxCount = value;
      });
    }).addToggle((toggle) => toggle.setValue(this.plugin.settings.HistoryToggle).onChange((value) => {
      this.plugin.settings.HistoryToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(indexGraphView).setName(t("play controller")).setDesc(t("play_des")).addToggle((toggle) => toggle.setValue(this.plugin.settings.playControllerToggle).onChange((value) => {
      this.plugin.settings.playControllerToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(indexGraphView).setName(t("Node menu")).setDesc(t("node_menu_des")).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(nodeMenuDiv);
      });
    });
    const nodeMenuDiv = indexGraphView.createDiv("zk-local-section zk-hidden");
    const commandsDiv = nodeMenuDiv.createDiv();
    this.updateNodeMenu(commandsDiv);
    const addCommandBtnDiv = nodeMenuDiv.createDiv("zk-center-button setting-item");
    const addCommandBtn = new import_obsidian7.ButtonComponent(addCommandBtnDiv);
    addCommandBtn.setButtonText(t("Add command")).setCta().onClick(async () => {
      let command = await new addCommandModal(this.app, this.plugin).awaitSelection();
      let icon;
      if (!command.hasOwnProperty("icon")) {
        icon = await new ChooseIconModal(this.app, this.plugin).awaitSelection();
      }
      let name = await new chooseCustomNameModal(this.app, command.name).awaitSelection();
      let newCommand = {
        id: command.id,
        name: name || command.name,
        icon: icon != null ? icon : command.icon,
        copyType: 0,
        active: true
      };
      this.plugin.settings.NodeCommands.push(newCommand);
      this.updateNodeMenu(commandsDiv);
    });
    const localGraphView = settingTabDiv.createDiv("zk-setting-section");
    new import_obsidian7.Setting(localGraphView).setName(t("Open close-relative graph")).setDesc(t("Mermaid graph to display parent, siblings and sons")).addToggle((toggle) => toggle.setValue(this.plugin.settings.FamilyGraphToggle).onChange((value) => {
      this.plugin.settings.FamilyGraphToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(familySectionDiv);
      });
    });
    const familySectionDiv = localGraphView.createDiv("zk-local-section zk-hidden");
    new import_obsidian7.Setting(familySectionDiv).setName(t("direction of graph")).addDropdown((options) => options.addOption("LR", t('"LR": feft to right')).addOption("RL", t('"RL": right to left')).addOption("TB", t('"TB": top to bottom')).addOption("BT", t('"BT": bottom to top')).setValue(this.plugin.settings.DirectionOfFamilyGraph).onChange((value) => {
      this.plugin.settings.DirectionOfFamilyGraph = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(localGraphView).setName(t("Open inlinks graph")).setDesc(t("Mermaid graph to display inlinks")).addToggle((toggle) => toggle.setValue(this.plugin.settings.InlinksGraphToggle).onChange((value) => {
      this.plugin.settings.InlinksGraphToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(inlinksSectionDiv);
      });
    });
    const inlinksSectionDiv = localGraphView.createDiv("zk-local-section zk-hidden");
    new import_obsidian7.Setting(inlinksSectionDiv).setName(t("direction of graph")).addDropdown((options) => options.addOption("LR", t('"LR": feft to right')).addOption("RL", t('"RL": right to left')).addOption("TB", t('"TB": top to bottom')).addOption("BT", t('"BT": bottom to top')).setValue(this.plugin.settings.DirectionOfInlinksGraph).onChange((value) => {
      this.plugin.settings.DirectionOfInlinksGraph = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(localGraphView).setName(t("Open outlinks graph")).setDesc(t("Mermaid graph to display outlinks")).addToggle((toggle) => toggle.setValue(this.plugin.settings.OutlinksGraphToggle).onChange((value) => {
      this.plugin.settings.OutlinksGraphToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(outlinksSectionDiv);
      });
    });
    const outlinksSectionDiv = localGraphView.createDiv("zk-local-section zk-hidden");
    new import_obsidian7.Setting(outlinksSectionDiv).setName(t("direction of graph")).addDropdown((options) => options.addOption("LR", t('"LR": feft to right')).addOption("RL", t('"RL": right to left')).addOption("TB", t('"TB": top to bottom')).addOption("BT", t('"BT": bottom to top')).setValue(this.plugin.settings.DirectionOfOutlinksGraph).onChange((value) => {
      this.plugin.settings.DirectionOfOutlinksGraph = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian7.Setting(outlinksSectionDiv).setName(t("Detect file extensions")).addDropdown((options) => options.addOption("all", t("all file extension")).addOption("md", t(".md only")).setValue(this.plugin.settings.FileExtension).onChange((value) => {
      this.plugin.settings.FileExtension = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    const experimentalDiv = settingTabDiv.createDiv("zk-setting-section");
    new import_obsidian7.Setting(experimentalDiv).setName(t("multiple IDs for main notes")).setDesc(t("multiple IDs description")).addToggle((toggle) => toggle.setValue(this.plugin.settings.multiIDToggle).onChange((value) => {
      this.plugin.settings.multiIDToggle = value;
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(multiIDDiv);
      });
    });
    const multiIDDiv = experimentalDiv.createDiv("zk-local-section zk-hidden");
    new import_obsidian7.Setting(multiIDDiv).setName(t("Specify a frontmatter field(list) for multiple IDs")).addText((cb) => cb.setValue(this.plugin.settings.multiIDField).onChange((value) => {
      this.plugin.settings.multiIDField = value;
    }));
    this.initDiv(topButtonsDiv);
  }
  openTabSection(selectNo, topButtonsDiv) {
    const sections = document.getElementsByClassName("zk-setting-section");
    const buttons = topButtonsDiv.querySelectorAll("button");
    for (let i = 0; i < sections.length; i++) {
      sections[i].addClass("zk-hidden");
      buttons[i].removeClass("is-active");
    }
    sections[selectNo].removeClass("zk-hidden");
    buttons[selectNo].addClass("is-active");
    this.plugin.settings.SectionTab = selectNo;
  }
  initDiv(topButtonsDiv) {
    this.openTabSection(this.plugin.settings.SectionTab, topButtonsDiv);
  }
  hideDiv(div) {
    if (!div.classList.contains("zk-hidden")) {
      div.addClass("zk-hidden");
    } else {
      div.removeClass("zk-hidden");
    }
  }
  async updateNodeMenu(nodeMenuDiv) {
    nodeMenuDiv.empty();
    const commandsLen = this.plugin.settings.NodeCommands.length;
    for (let i = 0; i < commandsLen; i++) {
      let command = this.plugin.settings.NodeCommands[i];
      let commandDiv = nodeMenuDiv.createEl("div", { cls: "setting-item" });
      new import_obsidian7.ExtraButtonComponent(commandDiv.createEl("div")).setIcon(command.icon).onClick(async () => {
        let icon = await new ChooseIconModal(this.app, this.plugin).awaitSelection();
        command.icon = icon;
        this.updateNodeMenu(nodeMenuDiv);
      });
      commandDiv.createEl("div", { text: command.name, cls: "command-text" });
      let copyIcon = "";
      let copyText = "";
      switch (command.copyType) {
        case 1:
          copyIcon = "copy";
          copyText = "id";
          break;
        case 2:
          copyIcon = "documents";
          copyText = t("file path");
          break;
        case 3:
          copyIcon = "calendar";
          copyText = t("created time");
          break;
        default:
          copyIcon = "circle-dashed";
          copyText = t("none");
          break;
      }
      new import_obsidian7.ExtraButtonComponent(commandDiv.createEl("div")).setIcon(copyIcon).setTooltip(t("auto-copy: ") + copyText).onClick(async () => {
        command.copyType = (command.copyType + 1) % 4;
        this.updateNodeMenu(nodeMenuDiv);
      });
      new import_obsidian7.ExtraButtonComponent(commandDiv.createEl("div")).setIcon("arrow-down").onClick(async () => {
        if (commandsLen > 1) {
          [this.plugin.settings.NodeCommands[i], this.plugin.settings.NodeCommands[(i + 1) % commandsLen]] = [this.plugin.settings.NodeCommands[(i + 1) % commandsLen], this.plugin.settings.NodeCommands[i]];
        }
        this.updateNodeMenu(nodeMenuDiv);
      });
      new import_obsidian7.ExtraButtonComponent(commandDiv.createEl("div")).setIcon("arrow-up").onClick(async () => {
        if (commandsLen > 1) {
          [this.plugin.settings.NodeCommands[i], this.plugin.settings.NodeCommands[(i - 1 + commandsLen) % commandsLen]] = [this.plugin.settings.NodeCommands[(i - 1 + commandsLen) % commandsLen], this.plugin.settings.NodeCommands[i]];
        }
        this.updateNodeMenu(nodeMenuDiv);
      });
      new import_obsidian7.ButtonComponent(commandDiv).setIcon("trash").setCta().setClass("mod-warning").onClick(() => {
        this.plugin.settings.NodeCommands.splice(i, 1);
        this.updateNodeMenu(nodeMenuDiv);
      });
    }
  }
  async hide() {
    if (this.plugin.RefreshIndexViewFlag === true) {
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
    }
    this.plugin.saveData(this.plugin.settings);
  }
};

// src/utils/utils.ts
var import_obsidian8 = require("obsidian");
async function ID_formatting(id, arr, siblingsOrder) {
  if (/^[0-9]$/.test(id[0])) {
    let numStr = id.match(/\d+/g);
    if (numStr && numStr.length > 0) {
      arr.push(numStr[0].padStart(4, "0"));
      let len = numStr[0].length;
      if (len < id.length) {
        return await ID_formatting(id.slice(len), arr, siblingsOrder);
      } else {
        return arr;
      }
    } else {
      return arr;
    }
  } else if (/^[a-zA-Z]$/.test(id[0])) {
    let letterStr;
    if (siblingsOrder === "letter") {
      letterStr = id[0].padStart(5, "0");
    } else {
      letterStr = id[0];
    }
    arr.push(letterStr);
    if (id.length === 1) {
      return arr;
    } else {
      return await ID_formatting(id.slice(1), arr, siblingsOrder);
    }
  } else {
    if (id.length === 1) {
      return arr;
    } else {
      return await ID_formatting(id.slice(1), arr, siblingsOrder);
    }
  }
}
async function mainNoteInit(plugin) {
  var _a, _b;
  let mainNoteFiles = this.app.vault.getMarkdownFiles();
  plugin.MainNotes = [];
  if (plugin.settings.FolderOfMainNotes !== "") {
    mainNoteFiles = mainNoteFiles.filter((file) => {
      return file.path.replace(file.name, "").startsWith(plugin.settings.FolderOfMainNotes + "/");
    });
  }
  if (plugin.settings.TagOfMainNotes !== "") {
    mainNoteFiles = mainNoteFiles.filter((file) => {
      var _a2, _b2, _c;
      return (_c = (_b2 = (_a2 = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a2.frontmatter) == null ? void 0 : _b2.tags) == null ? void 0 : _c.includes(plugin.settings.TagOfMainNotes.substring(1));
    });
  }
  for (let note of mainNoteFiles) {
    let IDArr = [];
    let node = {
      ID: "",
      IDArr,
      IDStr: "",
      position: 0,
      file: note,
      title: "",
      displayText: "",
      ctime: 0,
      randomId: random(16),
      nodeSons: 1,
      startY: 0,
      height: 0,
      isRoot: false,
      fixWidth: 0,
      branchName: "",
      gitNodePos: 0
    };
    let nodeCache = this.app.metadataCache.getFileCache(note);
    switch (plugin.settings.IDFieldOption) {
      case "1":
        node.ID = note.basename;
        node.IDArr = await ID_formatting(node.ID, node.IDArr, plugin.settings.siblingsOrder);
        node.IDStr = IDArr.toString();
        if (nodeCache !== null) {
          if (typeof nodeCache.frontmatter !== "undefined" && plugin.settings.TitleField !== "") {
            let title = (_a = nodeCache.frontmatter[plugin.settings.TitleField]) == null ? void 0 : _a.toString();
            if (typeof title == "string" && title.length > 0) {
              node.title = title;
            }
          }
        }
        break;
      case "2":
        if (nodeCache !== null) {
          if (typeof nodeCache.frontmatter !== "undefined" && plugin.settings.IDField !== "") {
            let id = nodeCache.frontmatter[plugin.settings.IDField];
            if (Array.isArray(id)) {
              node.ID = id[0].toString();
              node.IDArr = await ID_formatting(node.ID, node.IDArr, plugin.settings.siblingsOrder);
              node.IDStr = node.IDArr.toString();
              node.title = note.basename;
            } else if (typeof id == "string") {
              node.ID = id;
              node.IDArr = await ID_formatting(node.ID, node.IDArr, plugin.settings.siblingsOrder);
              node.IDStr = node.IDArr.toString();
              node.title = note.basename;
            } else if (typeof id == "number") {
              node.ID = id.toString();
              node.IDArr = await ID_formatting(node.ID, node.IDArr, plugin.settings.siblingsOrder);
              node.IDStr = node.IDArr.toString();
              node.title = note.basename;
            }
          }
        }
        if (node.ID == "") {
          continue;
        }
        break;
      case "3":
        node.ID = note.basename.split(plugin.settings.Separator)[0];
        node.IDArr = await ID_formatting(node.ID, node.IDArr, plugin.settings.siblingsOrder);
        node.IDStr = IDArr.toString();
        if (node.ID.length < note.basename.length - 1) {
          node.title = note.basename.substring(node.ID.length + 1);
        }
        break;
      default:
    }
    if (plugin.settings.CustomCreatedTime.length > 0) {
      let ctime = (_b = nodeCache == null ? void 0 : nodeCache.frontmatter) == null ? void 0 : _b[plugin.settings.CustomCreatedTime];
      if (ctime) {
        let time = (0, import_obsidian8.moment)(ctime);
        if (time.isValid()) {
          node.ctime = time.valueOf();
        }
      }
    }
    if (node.ctime === 0) {
      node.ctime = node.file.stat.ctime;
    }
    plugin.MainNotes.push(node);
  }
  if (plugin.settings.multiIDToggle == true && plugin.settings.multiIDField != "") {
    let duplicateNodes = [];
    for (let i = 0; i < plugin.MainNotes.length; i++) {
      let node = plugin.MainNotes[i];
      let fm = await this.app.metadataCache.getFileCache(node.file).frontmatter;
      if (fm) {
        let IDs = fm[plugin.settings.multiIDField];
        if (Array.isArray(IDs)) {
          for (let j = 0; j < IDs.length; j++) {
            let nodeDup = Object.assign({}, node);
            nodeDup.ID = IDs[j].toString();
            nodeDup.IDArr = await ID_formatting(nodeDup.ID, [], plugin.settings.siblingsOrder);
            nodeDup.IDStr = nodeDup.IDArr.toString();
            nodeDup.randomId = random(16);
            duplicateNodes.push(nodeDup);
          }
        } else if (typeof IDs == "string") {
          let nodeDup = Object.assign({}, node);
          nodeDup.ID = IDs;
          nodeDup.IDArr = await ID_formatting(nodeDup.ID, [], plugin.settings.siblingsOrder);
          nodeDup.IDStr = nodeDup.IDArr.toString();
          nodeDup.randomId = random(16);
          duplicateNodes.push(nodeDup);
        }
      }
    }
    if (duplicateNodes.length > 0) {
      plugin.MainNotes.push(...duplicateNodes);
      plugin.MainNotes = uniqueBy(plugin.MainNotes);
    }
  }
  plugin.MainNotes.sort((a, b) => a.IDStr.localeCompare(b.IDStr));
  for (let i = 0; i < plugin.MainNotes.length; i++) {
    let node = plugin.MainNotes[i];
    node.position = i;
    if (!plugin.MainNotes.find((n) => n.IDArr.toString() == node.IDArr.slice(0, -1).toString())) {
      node.isRoot = true;
    }
    switch (plugin.settings.NodeText) {
      case "id":
        node.displayText = node.ID;
        break;
      case "title":
        if (node.title == "") {
          node.displayText = node.ID;
        } else {
          node.displayText = node.title;
        }
        break;
      case "both":
        node.displayText = `${node.ID}: ${node.title}`;
        break;
      default:
    }
  }
}
var random = (e) => {
  let t2 = [];
  for (let n = 0; n < e; n++) {
    t2.push((16 * Math.random() | 0).toString(16));
  }
  return t2.join("");
};
function uniqueBy(arr) {
  const map = /* @__PURE__ */ new Map();
  const result = [];
  for (const item of arr) {
    const compoundKey = item.ID + "_" + item.file.path;
    if (!map.has(compoundKey)) {
      map.set(compoundKey, true);
      result.push(item);
    }
  }
  return result;
}
function displayWidth(str) {
  let length = 0;
  for (let i = 0; i < str.length; i++) {
    const charCode = str.charCodeAt(i);
    length += charCode >= 0 && charCode <= 128 ? 1 : 2;
  }
  return length;
}
async function addSvgPanZoom(zkGraph, indexMermaidDiv, i, plugin, mermaidStr, height) {
  const mermaid = await (0, import_obsidian8.loadMermaid)();
  let { svg } = await mermaid.render(`${zkGraph.id}-svg`, mermaidStr);
  zkGraph.insertAdjacentHTML("beforeend", svg);
  if (plugin.settings.graphType === "roadmap") {
    zkGraph.children[0].removeAttribute("style");
  }
  zkGraph.children[0].addClass("zk-full-width");
  zkGraph.children[0].setAttr("height", `${height}px`);
  indexMermaidDiv.appendChild(zkGraph);
  const svgPanZoom = require_browserify();
  let panZoomTiger = await svgPanZoom(`#${zkGraph.id}-svg`, {
    zoomEnabled: true,
    controlIconsEnabled: false,
    fit: true,
    center: true,
    minZoom: 1e-3,
    maxZoom: 1e3,
    dblClickZoomEnabled: false,
    zoomScaleSensitivity: 0.2,
    onZoom: async () => {
      plugin.settings.zoomPanScaleArr[i].zoomScale = panZoomTiger.getZoom();
    },
    onPan: async () => {
      plugin.settings.zoomPanScaleArr[i].pan = panZoomTiger.getPan();
    }
  });
  const touchSvg = document.getElementById(`${zkGraph.id}-svg`);
  if (touchSvg !== null) {
    let startDistance = 0;
    let scale = panZoomTiger.getZoom();
    let lastScale = scale;
    touchSvg.addEventListener("touchstart", (event) => {
      if (event.touches.length === 2) {
        let touch1 = event.touches[0];
        let touch2 = event.touches[1];
        startDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
      }
    });
    touchSvg.addEventListener("touchmove", (event) => {
      if (event.touches.length === 2) {
        let touch1 = event.touches[0];
        let touch2 = event.touches[1];
        let currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        let newScale = currentDistance / startDistance;
        scale = scale * newScale / lastScale;
        panZoomTiger.zoom(scale);
      }
    });
  }
  if (typeof plugin.settings.zoomPanScaleArr[i] === "undefined") {
    const setSvg = document.getElementById(`${zkGraph.id}-svg`);
    if (setSvg !== null) {
      let a = setSvg.children[0].getAttr("style");
      if (a) {
        let b = a.match(/\d([^\,]+)\d/g);
        if (b !== null && Number(b[0]) > 1) {
          panZoomTiger.zoom(1 / Number(b[0]));
        }
      }
      let zoomPanScale = {
        graphID: zkGraph.id,
        zoomScale: panZoomTiger.getZoom(),
        pan: panZoomTiger.getPan()
      };
      plugin.settings.zoomPanScaleArr.push(zoomPanScale);
    }
  } else {
    panZoomTiger.zoom(plugin.settings.zoomPanScaleArr[i].zoomScale);
    panZoomTiger.pan(plugin.settings.zoomPanScaleArr[i].pan);
  }
}

// src/view/graphView.ts
var import_obsidian14 = require("obsidian");

// src/view/indexView.ts
var import_obsidian12 = require("obsidian");

// src/modal/indexModal.ts
var import_obsidian9 = require("obsidian");
var indexModal = class extends import_obsidian9.SuggestModal {
  constructor(app, plugin, MainNotes, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.plugin = plugin;
    this.MainNotes = MainNotes;
    this.setPlaceholder(t("select an index"));
    this.limit = plugin.settings.maxLenIndexModel;
  }
  getSuggestions(query) {
    this.ALL_ZKIndex = [];
    this.query = query;
    const indexPath = this.plugin.settings.FolderOfIndexes;
    if (indexPath == "") {
      new import_obsidian9.Notice(t("Index folder not set!"));
    } else {
      const indexFiles = this.app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(indexPath + "/"));
      if (indexFiles.length == 0) {
        new import_obsidian9.Notice(`${t("No index can be found by path")} "${indexPath}"`);
      }
      const resolvedLinks = this.app.metadataCache.resolvedLinks;
      for (let file of indexFiles) {
        let frontLinks = Object.keys(resolvedLinks[file.path]).filter((l) => l.endsWith("md"));
        let outlinks = [];
        if (frontLinks.length > 0) {
          for (let link of frontLinks) {
            let file2 = this.app.vault.getFileByPath(link);
            if (file2 !== null) {
              let outlink = this.MainNotes.find((n) => n.file === file2);
              if (typeof outlink !== "undefined") {
                let count = this.MainNotes.filter((n) => n.IDStr.startsWith(outlink.IDStr)).length;
                outlinks.push(outlink.ID + ` (${count.toString()})`);
              } else {
                outlinks.push(file2.basename);
              }
            }
          }
        }
        this.ALL_ZKIndex.push({ keyword: file.basename, display: `\u3010${file.basename}\u3011: ${outlinks.toString()}`, path: file.path });
      }
      this.ALL_ZKIndex.sort(function(a, b) {
        return a["keyword"].localeCompare(b["keyword"]);
      });
    }
    this.ALL_ZKIndex = this.ALL_ZKIndex.filter((i) => i.keyword.toLowerCase().startsWith(query.toLowerCase()));
    return this.ALL_ZKIndex;
  }
  renderSuggestion(index, el) {
    (0, import_obsidian9.renderMatches)(el, index.display, [[0, this.query.length + 1]]);
  }
  onChooseSuggestion(index, evt) {
    this.index = index;
    this.onSubmit(this.index);
  }
};
var indexFuzzyModal = class extends import_obsidian9.FuzzySuggestModal {
  constructor(app, plugin, MainNotes, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.plugin = plugin;
    this.MainNotes = MainNotes;
    this.setPlaceholder(t("select an index"));
    this.limit = plugin.settings.maxLenIndexModel;
  }
  getItems() {
    this.ALL_ZKIndex = [];
    const indexPath = this.plugin.settings.FolderOfIndexes;
    if (indexPath == "") {
      new import_obsidian9.Notice(t("Index folder not set!"));
    } else {
      const indexFiles = this.app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(indexPath + "/"));
      if (indexFiles.length == 0) {
        new import_obsidian9.Notice(`${t("No index can be found by path")} "${indexPath}"`);
      }
      const resolvedLinks = this.app.metadataCache.resolvedLinks;
      for (let file of indexFiles) {
        let frontLinks = Object.keys(resolvedLinks[file.path]).filter((l) => l.endsWith("md"));
        let outlinks = [];
        if (frontLinks.length > 0) {
          for (let link of frontLinks) {
            let file2 = this.app.vault.getFileByPath(link);
            if (file2 !== null) {
              let outlinkArr = this.MainNotes.filter((n) => n.file === file2);
              if (outlinkArr.length > 0) {
                for (let outlink of outlinkArr) {
                  let count = this.MainNotes.filter((n) => n.IDStr.startsWith(outlink.IDStr)).length;
                  outlinks.push(outlink.ID + ` (${count.toString()})`);
                }
              } else {
                outlinks.push(file2.basename);
              }
            }
          }
        }
        this.ALL_ZKIndex.push({ keyword: file.basename, display: `\u3010${file.basename}\u3011: ${outlinks.toString()}`, path: file.path });
      }
      this.ALL_ZKIndex.sort(function(a, b) {
        return a["keyword"].localeCompare(b["keyword"]);
      });
    }
    return this.ALL_ZKIndex;
  }
  getItemText(index) {
    return index.display;
  }
  onChooseItem(index, evt) {
    this.index = index;
    this.onSubmit(this.index);
  }
};

// src/modal/mainNoteModal.ts
var import_obsidian10 = require("obsidian");
var mainNoteModal = class extends import_obsidian10.SuggestModal {
  constructor(app, plugin, MainNotes, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.plugin = plugin;
    this.MainNotes = MainNotes;
    this.setPlaceholder(t("select a main note"));
    this.limit = plugin.settings.maxLenMainModel;
  }
  getSuggestions(query) {
    let mainNotes = [];
    this.query = query;
    mainNotes = this.MainNotes.filter((node) => node.ID.toLowerCase().startsWith(query.toLowerCase()) || node.title.toLowerCase().startsWith(query.toLowerCase()));
    return mainNotes;
  }
  renderSuggestion(node, el) {
    let displayText = `${node.ID}: ${node.title}`;
    (0, import_obsidian10.renderMatches)(el, displayText, [[0, this.query.length]], this.getPosition(node));
  }
  onChooseSuggestion(node, evt) {
    this.selectZKNode = node;
    this.onSubmit(this.selectZKNode);
  }
  getPosition(node) {
    let position = 0;
    if (node.ID.toLocaleLowerCase().startsWith(this.query.toLocaleLowerCase())) {
      position = 0;
    } else {
      position = node.ID.length + 2;
    }
    return position;
  }
};
var mainNoteFuzzyModal = class extends import_obsidian10.FuzzySuggestModal {
  constructor(app, plugin, MainNotes, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.plugin = plugin;
    this.MainNotes = MainNotes;
    this.setPlaceholder(t("select a main note"));
    this.limit = plugin.settings.maxLenMainModel;
  }
  getItems() {
    return this.MainNotes;
  }
  getItemText(node) {
    return `${node.ID}: ${node.title}`;
  }
  onChooseItem(selectZKNode, evt) {
    this.selectZKNode = selectZKNode;
    this.onSubmit(this.selectZKNode);
  }
};

// src/modal/tableModal.ts
var import_obsidian11 = require("obsidian");
var tableModal = class extends import_obsidian11.Modal {
  constructor(app, plugin, tableArr) {
    super(app);
    this.headerStr = `|${t("note's ID")}|${t("note's title")}|${t("inlinks")}|${t("outlinks")}|${t("Time of creation")}|
| --- | --- | --- | --- | --- |
`;
    this.tableStr = "";
    this.plugin = plugin;
    this.tableArr = tableArr;
  }
  onOpen() {
    let { contentEl } = this;
    this.modalEl.addClass("zk-table-container");
    this.createToolBar(contentEl);
    this.createTable(contentEl);
  }
  createToolBar(contentEl) {
    const toolbarDiv = contentEl.createDiv("zk-table-toolbar");
    toolbarDiv.empty();
    const copyTableIcon = new import_obsidian11.ExtraButtonComponent(toolbarDiv);
    copyTableIcon.setIcon("copy").setTooltip(t("Copy markdown table"));
    copyTableIcon.onClick(async () => {
      await this.copyTableStr();
    });
  }
  createTable(contentEl) {
    const contentDiv = contentEl.createDiv("zk-table-view");
    contentDiv.id = "zk-table-view";
    this.appendTableLine();
    import_obsidian11.MarkdownRenderer.render(this.app, this.tableStr, contentDiv, "", this.plugin);
    this.addLinkAndPreview();
  }
  async copyTableStr() {
    this.appendTableLine();
    this.tableStr = this.tableStr.replace(/<ul><li>/g, "").replace(/<\/li><\/ul>/g, "").replace(/<\/li><li>/g, "<br>");
    await navigator.clipboard.writeText(this.tableStr);
    new import_obsidian11.Notice(t("Copy markdown table"));
  }
  appendTableLine() {
    var _a;
    this.tableStr = this.headerStr;
    for (let node of this.tableArr) {
      let inlinksStr = "";
      for (let inlink of this.getInlinks(node.file)) {
        inlinksStr = inlinksStr + `<li>[[${inlink.basename}]]</li>`;
      }
      if (inlinksStr !== "") {
        inlinksStr = `<ul>${inlinksStr}</ul>`;
      }
      let outlinkStr = "";
      let outlinks = (_a = this.app.metadataCache.getFileCache(node.file)) == null ? void 0 : _a.links;
      if (outlinks) {
        for (let outlink of outlinks) {
          outlinkStr = outlinkStr + `<li> ${outlink.original.replace(`|`, `\\|`)}</li>`;
        }
      }
      if (outlinkStr !== "") {
        outlinkStr = `<ul>${outlinkStr}</ul>`;
      }
      this.tableStr = this.tableStr + `|[[${node.ID}]]|${node.title.replace(`|`, `\\|`)}|${inlinksStr}|${outlinkStr}|${(0, import_obsidian11.moment)(node.ctime).format(this.plugin.settings.datetimeFormat)}|
`;
    }
  }
  getInlinks(currentFile) {
    let inlinkArr = [];
    const resolvedLinks = this.app.metadataCache.resolvedLinks;
    for (let src of Object.keys(resolvedLinks)) {
      let link = resolvedLinks[src];
      for (let dest of Object.keys(link)) {
        if (dest === currentFile.path) {
          let inlinkFile = this.app.vault.getFileByPath(src);
          if (inlinkFile !== null) {
            inlinkArr.push(inlinkFile);
          }
        }
      }
    }
    return inlinkArr;
  }
  addLinkAndPreview() {
    let tableDiv = document.getElementById("zk-table-view");
    if (tableDiv !== null) {
      let links = tableDiv.getElementsByTagName("a");
      for (let i = 0; i < links.length; i++) {
        let href = links[i].getAttribute("href");
        if (href) {
          let linkStr = href;
          let node = this.tableArr.find((n) => n.ID == linkStr);
          if (node) {
            linkStr = node.file.basename;
          }
          links[i].addEventListener("click", (event) => {
            if (event.ctrlKey) {
              this.app.workspace.openLinkText(linkStr, "", "tab");
            } else {
              this.app.workspace.openLinkText(linkStr, "");
            }
          });
          links[i].addEventListener(`mouseover`, (event) => {
            this.app.workspace.trigger(`hover-link`, {
              event,
              source: ZK_NAVIGATION,
              hoverParent: tableDiv,
              linktext: linkStr,
              targetEl: links[i],
              sourcePath: ""
            });
          });
        }
      }
    }
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/view/indexView.ts
var ZK_INDEX_TYPE = "zk-index-type";
var ZK_INDEX_VIEW = t("zk-index-graph");
var ZK_NAVIGATION = "zk-navigation";
var ZKIndexView = class extends import_obsidian12.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.playStatus = {
      current: 0,
      total: 0,
      nodeGArr: [],
      lines: [],
      labels: []
    };
    this.refreshIndexLayout = async () => {
      if (this.plugin.settings.FolderOfMainNotes == "" && this.plugin.settings.TagOfMainNotes == "") {
        new import_obsidian12.Notice(t("\u274CSetting error: no folder or tag specified for main notes!"));
        return;
      } else {
        await this.IndexViewInterfaceInit();
      }
    };
    this.plugin = plugin;
  }
  getViewType() {
    return ZK_INDEX_TYPE;
  }
  getDisplayText() {
    return ZK_INDEX_VIEW;
  }
  getIcon() {
    return "ghost";
  }
  onResize() {
    if (this.app.workspace.getLeavesOfType(ZK_INDEX_TYPE).length > 0 && this.containerEl.offsetHeight !== 0) {
      if (this.plugin.indexViewOffsetHeight !== this.containerEl.offsetHeight || this.plugin.indexViewOffsetWidth !== this.containerEl.offsetWidth) {
        this.app.workspace.trigger("zk-navigation:refresh-index-graph");
      }
    }
  }
  async IndexViewInterfaceInit() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("zk-view-content");
    const toolbarDiv = containerEl.createDiv("zk-index-toolbar");
    const indexMermaidDiv = containerEl.createDiv("zk-index-mermaid-container");
    indexMermaidDiv.id = "zk-index-mermaid-container";
    indexMermaidDiv.empty();
    if (this.plugin.settings.MainNoteButton == true) {
      const mainNoteButtonDiv = toolbarDiv.createDiv("zk-index-toolbar-block");
      const mainNoteButton = new import_obsidian12.ButtonComponent(mainNoteButtonDiv).setClass("zk-index-toolbar-button");
      mainNoteButton.setButtonText(this.plugin.settings.MainNoteButtonText);
      mainNoteButton.setCta();
      mainNoteButton.onClick(() => {
        if (this.plugin.settings.MainNoteSuggestMode === "IDOrder") {
          new mainNoteModal(this.app, this.plugin, this.plugin.MainNotes, (selectZKNode) => {
            this.plugin.settings.lastRetrival = {
              type: "main",
              ID: selectZKNode.ID,
              displayText: selectZKNode.displayText,
              filePath: selectZKNode.file.path,
              openTime: (0, import_obsidian12.moment)().format("YYYY-MM-DD HH:mm:ss")
            };
            this.plugin.clearShowingSettings();
            this.app.workspace.trigger("zk-navigation:refresh-index-graph");
          }).open();
        } else {
          new mainNoteFuzzyModal(this.app, this.plugin, this.plugin.MainNotes, (selectZKNode) => {
            this.plugin.settings.lastRetrival = {
              type: "main",
              ID: selectZKNode.ID,
              displayText: selectZKNode.displayText,
              filePath: selectZKNode.file.path,
              openTime: (0, import_obsidian12.moment)().format("YYYY-MM-DD HH:mm:ss")
            };
            this.plugin.clearShowingSettings();
            this.app.workspace.trigger("zk-navigation:refresh-index-graph");
          }).open();
        }
      });
    }
    if (this.plugin.settings.IndexButton == true) {
      const indexButtonDiv = toolbarDiv.createDiv("zk-index-toolbar-block");
      const indexButton = new import_obsidian12.ButtonComponent(indexButtonDiv).setClass("zk-index-toolbar-button");
      indexButton.setButtonText(this.plugin.settings.IndexButtonText);
      indexButton.setCta();
      indexButton.onClick(() => {
        if (this.plugin.settings.SuggestMode === "keywordOrder") {
          new indexModal(this.app, this.plugin, this.plugin.MainNotes, (index) => {
            this.plugin.settings.lastRetrival = {
              type: "index",
              ID: "",
              displayText: index.keyword,
              filePath: index.path,
              openTime: (0, import_obsidian12.moment)().format("YYYY-MM-DD HH:mm:ss")
            };
            this.plugin.clearShowingSettings();
            this.app.workspace.trigger("zk-navigation:refresh-index-graph");
          }).open();
        } else {
          new indexFuzzyModal(this.app, this.plugin, this.plugin.MainNotes, (index) => {
            this.plugin.settings.lastRetrival = {
              type: "index",
              ID: "",
              displayText: index.keyword,
              filePath: index.path,
              openTime: (0, import_obsidian12.moment)().format("YYYY-MM-DD HH:mm:ss")
            };
            this.plugin.clearShowingSettings();
            this.app.workspace.trigger("zk-navigation:refresh-index-graph");
          }).open();
        }
      });
    }
    const startingDiv = toolbarDiv.createDiv("zk-index-toolbar-block");
    startingDiv.createEl("b", { text: t("Display from : ") });
    const startPoint = new import_obsidian12.DropdownComponent(startingDiv);
    startPoint.addOption("index", t("index")).addOption("parent", t("parent")).addOption("root", t("root")).setValue(this.plugin.settings.StartingPoint).onChange((StartPoint) => {
      this.plugin.settings.StartingPoint = StartPoint;
      this.plugin.clearShowingSettings(this.plugin.settings.BranchTab);
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
    });
    const displayLevelDiv = toolbarDiv.createDiv("zk-index-toolbar-block");
    displayLevelDiv.createEl("b", { text: t("To : ") });
    const displayLevel = new import_obsidian12.DropdownComponent(displayLevelDiv);
    displayLevel.addOption("next", t("next")).addOption("end", t("end")).setValue(this.plugin.settings.DisplayLevel).onChange((DisplayLevel) => {
      this.plugin.settings.DisplayLevel = DisplayLevel;
      this.plugin.clearShowingSettings(this.plugin.settings.BranchTab);
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
    });
    const nodeTextDiv = toolbarDiv.createDiv("zk-index-toolbar-block");
    nodeTextDiv.createEl("b", { text: t("Text : ") });
    const nodeText = new import_obsidian12.DropdownComponent(nodeTextDiv);
    nodeText.addOption("id", t("id")).addOption("title", t("title")).addOption("both", t("both")).setValue(this.plugin.settings.NodeText).onChange((NodeText) => {
      this.plugin.settings.NodeText = NodeText;
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
      this.app.workspace.trigger("zk-navigation:refresh-local-graph");
    });
    const graphTypeDiv = toolbarDiv.createDiv("zk-index-toolbar-block");
    graphTypeDiv.createEl("b", { text: t("style : ") });
    const graphType = new import_obsidian12.DropdownComponent(graphTypeDiv);
    graphType.addOption("structure", t("structure")).addOption("roadmap", t("roadmap")).setValue(this.plugin.settings.graphType).onChange((graphType2) => {
      this.plugin.settings.graphType = graphType2;
      this.plugin.clearShowingSettings(this.plugin.settings.BranchTab);
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
      this.app.workspace.trigger("zk-navigation:refresh-local-graph");
    });
    await this.refreshBranchMermaid();
  }
  async onload() {
    this.registerEvent(this.app.workspace.on("active-leaf-change", async (leaf) => {
      if ((leaf == null ? void 0 : leaf.view.getViewType()) == ZK_INDEX_TYPE) {
        if (this.plugin.RefreshIndexViewFlag == true) {
          await this.IndexViewInterfaceInit();
        }
      }
    }));
    this.registerEvent(this.app.vault.on("rename", async () => {
      this.plugin.RefreshIndexViewFlag = true;
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
    }));
    this.registerEvent(this.app.vault.on("modify", async () => {
      this.plugin.RefreshIndexViewFlag = true;
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
    }));
    this.registerEvent(this.app.vault.on("create", async () => {
      this.plugin.RefreshIndexViewFlag = true;
    }));
    this.registerEvent(this.app.vault.on("delete", async () => {
      this.plugin.RefreshIndexViewFlag = true;
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
    }));
    this.registerEvent(this.app.metadataCache.on("changed", async () => {
      this.plugin.RefreshIndexViewFlag = true;
    }));
    this.registerEvent(this.app.metadataCache.on("deleted", async () => {
      this.plugin.RefreshIndexViewFlag = true;
    }));
    const refresh = (0, import_obsidian12.debounce)(this.refreshIndexLayout, 300, true);
    this.registerEvent(this.app.workspace.on("zk-navigation:refresh-index-graph", refresh));
  }
  async onOpen() {
    if (this.app.workspace.layoutReady) {
      this.refreshIndexLayout();
    } else {
      this.app.workspace.onLayoutReady(() => {
        this.refreshIndexLayout();
      });
    }
  }
  async refreshBranchMermaid() {
    const indexMermaidDiv = document.getElementById("zk-index-mermaid-container");
    if (!indexMermaidDiv)
      return;
    await mainNoteInit(this.plugin);
    indexMermaidDiv.empty();
    let branchEntranceNodeArr = [];
    let indexFile;
    const indexLinkDiv = indexMermaidDiv.createDiv("zk-index-link");
    indexLinkDiv.empty();
    if (this.plugin.settings.BranchToolbra == true) {
      const toolButtonsDiv = indexMermaidDiv.createDiv("zk-tool-buttons");
      toolButtonsDiv.empty();
      if (this.plugin.settings.settingIcon == true) {
        const settingBtn = new import_obsidian12.ExtraButtonComponent(toolButtonsDiv);
        settingBtn.setIcon("settings").setTooltip(t("settings"));
        settingBtn.onClick(() => {
          this.app.setting.open();
          this.app.setting.openTabById("zettelkasten-navigation");
        });
      }
      if (this.plugin.settings.exportCanvas == true) {
        const canvasBtn = new import_obsidian12.ExtraButtonComponent(toolButtonsDiv);
        canvasBtn.setIcon("layout-dashboard").setTooltip(t("export to canvas"));
        canvasBtn.onClick(async () => {
          if (this.plugin.settings.graphType === "structure") {
            await this.generateCanvasStr();
          } else {
            await this.generateCanvasStrGit();
          }
          await this.exportToCanvas();
        });
      }
      if (this.plugin.settings.RandomMainNote == true && this.plugin.settings.MainNoteButton) {
        const randomBtn = new import_obsidian12.ExtraButtonComponent(toolButtonsDiv);
        randomBtn.setIcon("dice-3").setTooltip(t("random main note"));
        randomBtn.onClick(async () => {
          if (this.plugin.settings.FolderOfMainNotes == "" && this.plugin.settings.TagOfMainNotes == "") {
            new import_obsidian12.Notice(t("\u274CSetting error: no folder or tag specified for main notes!"));
            return;
          } else {
            let randomMainNoteNode = this.plugin.MainNotes[Math.floor(Math.random() * this.plugin.MainNotes.length)];
            this.plugin.settings.lastRetrival = {
              type: "main",
              ID: randomMainNoteNode.ID,
              displayText: randomMainNoteNode.displayText,
              filePath: randomMainNoteNode.file.path,
              openTime: (0, import_obsidian12.moment)().format("YYYY-MM-DD HH:mm:ss")
            };
            await this.plugin.clearShowingSettings();
            await this.IndexViewInterfaceInit();
          }
        });
      }
      if (this.plugin.settings.RandomIndex == true && this.plugin.settings.IndexButton) {
        const randomBtn = new import_obsidian12.ExtraButtonComponent(toolButtonsDiv);
        randomBtn.setIcon("dices").setTooltip(t("random index"));
        randomBtn.onClick(async () => {
          if (this.plugin.settings.FolderOfIndexes == "") {
            new import_obsidian12.Notice(t("\u274CSetting error: no folder specified for index!"));
            return;
          } else {
            const indexFiles = this.app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(this.plugin.settings.FolderOfIndexes + "/"));
            let randomIndex = indexFiles[Math.floor(Math.random() * indexFiles.length)];
            this.plugin.settings.lastRetrival = {
              type: "index",
              ID: "",
              displayText: randomIndex.name,
              filePath: randomIndex.path,
              openTime: (0, import_obsidian12.moment)().format("YYYY-MM-DD HH:mm:ss")
            };
            await this.plugin.clearShowingSettings();
            await this.IndexViewInterfaceInit();
          }
        });
      }
      if (this.plugin.settings.showAllToggle == true) {
        const showAllBtn = new import_obsidian12.ExtraButtonComponent(toolButtonsDiv);
        showAllBtn.setIcon("trees").setTooltip(t("all trees"));
        showAllBtn.onClick(async () => {
          this.plugin.settings.lastRetrival = {
            type: "all",
            ID: "",
            displayText: "all trees",
            filePath: "",
            openTime: (0, import_obsidian12.moment)().format("YYYY-MM-DD HH:mm:ss")
          };
          this.plugin.settings.showAll = true;
          this.plugin.settings.DisplayLevel = "end";
          await this.plugin.clearShowingSettings();
          await this.IndexViewInterfaceInit();
        });
      }
      if (this.plugin.settings.playControllerToggle === true) {
        const playControllerDiv = indexMermaidDiv.createDiv("zk-play-controller");
        const previousBtn = new import_obsidian12.ExtraButtonComponent(playControllerDiv);
        previousBtn.setIcon("arrow-left").setTooltip(t("playPrevious")).onClick(async () => {
          this.playStatus.current = (this.playStatus.current - 1 + this.playStatus.total) % this.playStatus.total;
          if (this.plugin.settings.graphType === "structure") {
            await this.branchPlaying();
          } else {
            await this.branchPlayingGit();
          }
        });
        const nextBtn = new import_obsidian12.ExtraButtonComponent(playControllerDiv);
        nextBtn.setIcon("arrow-right").setTooltip(t("playNext")).onClick(async () => {
          this.playStatus.current = (this.playStatus.current + 1) % this.playStatus.total;
          if (this.plugin.settings.graphType === "structure") {
            await this.branchPlaying();
          } else {
            await this.branchPlayingGit();
          }
        });
        const fullScreenBtn = new import_obsidian12.ExtraButtonComponent(playControllerDiv);
        fullScreenBtn.setIcon("fullscreen").setTooltip(t("fullscreen")).onClick(() => {
          let toggleClassList = [
            ".workspace-ribbon.side-dock-ribbon.mod-left",
            ".workspace-split.mod-horizontal.mod-left-split",
            ".workspace-tab-header-container",
            ".titlebar-button-container.mod-right",
            `.status-bar`
          ];
          toggleClassList.forEach((cls) => {
            const elements = document.querySelectorAll(cls);
            if (cls && elements) {
              elements.forEach((element, i) => {
                const cname = "zk-hidden";
                if (element.classList.contains(cname)) {
                  element.removeClass(cname);
                } else {
                  element.addClass(cname);
                }
              });
            }
          });
        });
        const playBtn = new import_obsidian12.ExtraButtonComponent(playControllerDiv);
        playBtn.setIcon("wand-2").setTooltip(t("growing animation"));
        playBtn.onClick(async () => {
          if (this.plugin.settings.graphType === "structure") {
            this.plugin.settings.FoldNodeArr = [];
            await this.branchGrowing();
          } else {
            await this.branchGrowingGit();
          }
        });
      }
      if (this.plugin.settings.TableView == true) {
        const tableBtn = new import_obsidian12.ExtraButtonComponent(toolButtonsDiv);
        tableBtn.setIcon("table").setTooltip(t("table view"));
        tableBtn.onClick(async () => {
          this.plugin.tableArr = this.branchAllNodes[this.plugin.settings.BranchTab].branchNodes.sort((a, b) => a.IDStr.localeCompare(b.IDStr));
          new tableModal(this.app, this.plugin, this.plugin.tableArr).open();
        });
      }
      if (this.plugin.settings.ListTree == true) {
        const listBtn = new import_obsidian12.ExtraButtonComponent(toolButtonsDiv);
        listBtn.setIcon("list-tree").setTooltip(t("list tree"));
        listBtn.onClick(async () => {
          this.plugin.tableArr = this.branchAllNodes[this.plugin.settings.BranchTab].branchNodes.sort((a, b) => a.IDStr.localeCompare(b.IDStr));
          await this.plugin.openOutlineView();
        });
      }
      if (this.plugin.settings.HistoryToggle == true) {
        const historyBtn = new import_obsidian12.ExtraButtonComponent(toolButtonsDiv);
        historyBtn.setIcon("history").setTooltip(t("History List"));
        historyBtn.onClick(async () => {
          this.plugin.openRecentView();
        });
      }
    }
    switch (this.plugin.settings.lastRetrival.type) {
      case "main":
        let selectZKNodes = this.plugin.MainNotes.filter((n) => n.file.path == this.plugin.settings.lastRetrival.filePath);
        if (selectZKNodes.length > 0) {
          if (this.plugin.settings.lastRetrival.ID !== "") {
            let nodeIndex = selectZKNodes.findIndex((n) => n.ID == this.plugin.settings.lastRetrival.ID);
            if (nodeIndex !== -1) {
              this.plugin.settings.BranchTab = nodeIndex;
            }
          } else {
            this.plugin.settings.lastRetrival.ID = selectZKNodes[0].ID;
            this.plugin.settings.lastRetrival.displayText = selectZKNodes[0].displayText;
          }
        }
        if (selectZKNodes.length == 0) {
          new import_obsidian12.Notice(`Invalid main note: ${this.plugin.settings.lastRetrival.filePath}`);
          return;
        }
        branchEntranceNodeArr.push(...selectZKNodes);
        indexLinkDiv.createEl("abbr", { text: t("Current note: ") });
        indexFile = this.app.vault.getFileByPath(this.plugin.settings.lastRetrival.filePath);
        this.unshiftHistoryList(this.plugin.settings.lastRetrival);
        break;
      case "index":
        if (!this.plugin.settings.lastRetrival.filePath.startsWith(this.plugin.settings.FolderOfIndexes))
          return;
        branchEntranceNodeArr = await this.getBranchEntranceNode(this.plugin.settings.lastRetrival);
        indexLinkDiv.createEl("abbr", { text: t("Current index: ") });
        indexFile = this.app.vault.getFileByPath(this.plugin.settings.lastRetrival.filePath);
        this.plugin.settings.lastRetrival.displayText = indexFile.basename;
        this.unshiftHistoryList(this.plugin.settings.lastRetrival);
        break;
      case "all":
        indexLinkDiv.createEl("abbr", { text: t("all trees") });
        branchEntranceNodeArr = this.plugin.MainNotes.filter((n) => n.isRoot == true);
        this.plugin.settings.lastRetrival = {
          type: "all",
          ID: "",
          displayText: t("all trees"),
          filePath: "",
          openTime: ""
        };
        this.unshiftHistoryList(this.plugin.settings.lastRetrival);
        break;
      default:
        let node = this.plugin.MainNotes[Math.floor(Math.random() * this.plugin.MainNotes.length)];
        if (node) {
          this.plugin.settings.lastRetrival = {
            type: "main",
            ID: node.ID,
            displayText: node.displayText,
            filePath: node.file.path,
            openTime: ""
          };
        }
        branchEntranceNodeArr.push(node);
        indexLinkDiv.createEl("abbr", { text: t("Current note: ") });
        this.unshiftHistoryList(this.plugin.settings.lastRetrival);
        indexFile = this.app.vault.getFileByPath(this.plugin.settings.lastRetrival.filePath);
        break;
    }
    if (indexFile instanceof import_obsidian12.TFile) {
      let link = indexLinkDiv.createEl("a", { text: `\u3010${this.plugin.settings.lastRetrival.displayText}\u3011` });
      link.addEventListener("click", (event) => {
        if (event.ctrlKey) {
          this.app.workspace.openLinkText("", indexFile.path, "tab");
        } else {
          this.app.workspace.openLinkText("", indexFile.path);
        }
      });
      link.addEventListener(`mouseover`, (event) => {
        this.app.workspace.trigger(`hover-link`, {
          event,
          source: ZK_NAVIGATION,
          hoverParent: link,
          linktext: indexFile.basename,
          targetEl: link,
          sourcePath: indexFile.path
        });
      });
    }
    if (branchEntranceNodeArr.length > 0) {
      switch (this.plugin.settings.graphType) {
        case "structure":
          await this.generateFlowchart(branchEntranceNodeArr, indexMermaidDiv);
          break;
        case "roadmap":
          await this.generateGitgraph(branchEntranceNodeArr, indexMermaidDiv);
          break;
        default:
      }
      await this.addBranchIcon(branchEntranceNodeArr, indexLinkDiv);
    }
    if (this.plugin.settings.ListTree === true) {
      this.plugin.tableArr = this.branchAllNodes[this.plugin.settings.BranchTab].branchNodes.sort((a, b) => a.IDStr.localeCompare(b.IDStr));
      this.app.workspace.trigger("zk-navigation:refresh-outline-view");
    }
    if (this.plugin.settings.HistoryToggle === true) {
      this.app.workspace.trigger("zk-navigation:refresh-recent-view");
    }
    if (this.plugin.settings.playControllerToggle === true) {
      this.resetController();
    }
    this.plugin.indexViewOffsetWidth = this.containerEl.offsetWidth;
    this.plugin.indexViewOffsetHeight = this.containerEl.offsetHeight;
  }
  async addBranchIcon(branchEntranceNodeArr, indexLinkDiv) {
    if (branchEntranceNodeArr.length > 1) {
      indexLinkDiv.createEl("small", { text: ` >> ` });
      for (let i = 0; i < branchEntranceNodeArr.length; i++) {
        let branchTab = indexLinkDiv.createEl("span").createEl("a", { text: `\u{1F33F}${i + 1} `, cls: "zk-branch-tab" });
        let node = branchEntranceNodeArr[i];
        (0, import_obsidian12.setTooltip)(branchTab, `${node.displayText} (${this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(node.IDStr)).length})`);
        branchTab.addEventListener("click", async () => {
          await this.openBranchTab(i);
          this.resetController();
        });
      }
      await this.openBranchTab(this.plugin.settings.BranchTab);
    }
  }
  async generateFlowchart(branchEntranceNodeArr, indexMermaidDiv) {
    this.branchAllNodes = [];
    for (let i = 0; i < branchEntranceNodeArr.length; i++) {
      const branchNodes = await this.getBranchNodes(branchEntranceNodeArr[i]);
      this.branchAllNodes.push({ branchTab: i, branchNodes });
      let mermaidStr = await this.generateFlowchartStr(branchNodes, branchEntranceNodeArr[i], this.plugin.settings.DirectionOfBranchGraph);
      let zkGraph = indexMermaidDiv.createEl("div", { cls: "zk-index-mermaid" });
      zkGraph.id = `zk-index-mermaid-${i}`;
      await addSvgPanZoom(zkGraph, indexMermaidDiv, i, this.plugin, mermaidStr, this.containerEl.offsetHeight - 100);
      const indexMermaid = document.getElementById(zkGraph.id);
      if (indexMermaid !== null) {
        let nodeGArr = indexMermaid.querySelectorAll("[id^='flowchart-']");
        let flowchartG = indexMermaid.querySelector("g.nodes");
        if (flowchartG !== null) {
          let nodeArr = flowchartG.getElementsByClassName("nodeLabel");
          for (let i2 = 0; i2 < nodeArr.length; i2++) {
            let link = document.createElement("a");
            link.addClass("internal-link");
            let nodePosStr = nodeGArr[i2].id.split("-")[1];
            let node = this.plugin.MainNotes.filter((n) => n.position == Number(nodePosStr))[0];
            link.textContent = nodeArr[i2].getText();
            nodeArr[i2].textContent = "";
            nodeArr[i2].appendChild(link);
            nodeGArr[i2].addEventListener("contextmenu", (event) => {
              const menu = new import_obsidian12.Menu();
              for (let command of this.plugin.settings.NodeCommands) {
                menu.addItem((item) => item.setTitle(command.name).setIcon(command.icon).onClick(async () => {
                  let copyStr = "";
                  switch (command.copyType) {
                    case 1:
                      copyStr = node.ID;
                      break;
                    case 2:
                      copyStr = node.file.path;
                      break;
                    case 3:
                      copyStr = (0, import_obsidian12.moment)(node.ctime).format(this.plugin.settings.datetimeFormat);
                      break;
                    default:
                      break;
                  }
                  if (copyStr !== "") {
                    await navigator.clipboard.writeText(copyStr);
                  }
                  this.app.commands.executeCommandById(command.id);
                }));
              }
              menu.showAtMouseEvent(event);
            });
            if (this.plugin.settings.displayTimeToggle === true) {
              let nodeParent = nodeArr[i2].parentElement;
              if (nodeParent !== null) {
                (0, import_obsidian12.setTooltip)(nodeParent, `${t("created")}: ${(0, import_obsidian12.moment)(node.ctime).format(this.plugin.settings.datetimeFormat)}`);
              }
            }
            nodeArr[i2].addEventListener("click", async (event) => {
              if (event.ctrlKey) {
                this.app.workspace.openLinkText("", node.file.path, "tab");
                event.stopPropagation();
              }
            });
            nodeGArr[i2].addEventListener("click", async (event) => {
              if (event.ctrlKey) {
                navigator.clipboard.writeText(node.ID);
                new import_obsidian12.Notice(node.ID + " copied");
              } else if (event.shiftKey) {
                this.plugin.settings.lastRetrival = {
                  type: "main",
                  ID: node.ID,
                  displayText: node.displayText,
                  filePath: node.file.path,
                  openTime: (0, import_obsidian12.moment)().format("YYYY-MM-DD HH:mm:ss")
                };
                await this.plugin.clearShowingSettings();
                await this.IndexViewInterfaceInit();
              } else if (event.altKey) {
                this.plugin.retrivalforLocaLgraph = {
                  type: "1",
                  ID: node.ID,
                  filePath: node.file.path
                };
                this.plugin.openGraphView();
              } else {
                this.app.workspace.openLinkText("", node.file.path);
              }
            });
            nodeGArr[i2].addEventListener("touchend", () => {
              this.app.workspace.openLinkText("", node.file.path);
            });
            nodeGArr[i2].addEventListener(`mouseover`, (event) => {
              this.app.workspace.trigger(`hover-link`, {
                event,
                source: ZK_NAVIGATION,
                hoverParent: this,
                linktext: node.file.basename,
                targetEl: link,
                sourcePath: node.file.path
              });
            });
          }
        }
        for (let foldNode of this.plugin.settings.FoldNodeArr.filter((n) => n.graphID == zkGraph.id)) {
          let hideNodes = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(foldNode.nodeIDstr) && n.IDStr !== foldNode.nodeIDstr);
          for (let hideNode of hideNodes) {
            let hideNodeGArr = indexMermaid.querySelectorAll(`[id^='flowchart-${hideNode.position}']`);
            hideNodeGArr.forEach((item) => {
              item.setAttr("style", "display:none");
            });
            let hideLines2 = indexMermaid.querySelectorAll(`[id^='L_${hideNode.position}']`);
            hideLines2.forEach((item) => {
              item.setAttr("style", "display:none");
            });
          }
          let hideLines = indexMermaid.querySelectorAll(`[id^='L_${foldNode.position}']`);
          hideLines.forEach((item) => {
            item.setAttr("style", "display:none");
          });
        }
        if (this.plugin.settings.FoldToggle == true) {
          await this.addFoldIcon(indexMermaid);
        }
      }
    }
  }
  async generateGitgraph(branchEntranceNodeArr, indexMermaidDiv) {
    this.branchAllNodes = [];
    this.allGitBranch = [];
    for (let i = 0; i < branchEntranceNodeArr.length; i++) {
      const branchNodes = await this.getBranchNodes(branchEntranceNodeArr[i]);
      this.branchAllNodes.push({ branchTab: i, branchNodes });
      let mermaidStr = await this.generateGitgraphStr(branchNodes, branchEntranceNodeArr[i], i);
      let zkGraph = indexMermaidDiv.createEl("div", { cls: "zk-index-mermaid" });
      zkGraph.id = `zk-index-mermaid-${i}`;
      await addSvgPanZoom(zkGraph, indexMermaidDiv, i, this.plugin, mermaidStr, this.containerEl.offsetHeight - 100);
      const indexMermaid = document.getElementById(zkGraph.id);
      if (indexMermaid !== null) {
        const gElements = indexMermaid.querySelectorAll("g.commit-bullets");
        let temNode = gElements[1];
        const circles = gElements[1].querySelectorAll("circle.commit");
        const circleNodes = Array.from(circles);
        gElements[1].textContent = "";
        for (let j = 0; j < circleNodes.length; j++) {
          let link = document.createElementNS("http://www.w3.org/2000/svg", "a");
          link.appendChild(circleNodes[j]);
          gElements[1].appendChild(link);
          let nodes = this.branchAllNodes[i].branchNodes;
          let nodeArr = nodes.filter((n) => n.gitNodePos === j);
          if (nodeArr.length > 0) {
            let node = nodeArr[0];
            circleNodes[j].addEventListener("click", async (event) => {
              if (event.ctrlKey) {
                this.app.workspace.openLinkText("", node.file.path, "tab");
              } else if (event.shiftKey) {
                this.plugin.settings.lastRetrival = {
                  type: "main",
                  ID: node.ID,
                  displayText: node.displayText,
                  filePath: node.file.path,
                  openTime: (0, import_obsidian12.moment)().format("YYYY-MM-DD HH:mm:ss")
                };
                await this.plugin.clearShowingSettings();
                await this.IndexViewInterfaceInit();
              } else if (event.altKey) {
                this.plugin.retrivalforLocaLgraph = {
                  type: "1",
                  ID: node.ID,
                  filePath: node.file.path
                };
                this.plugin.openGraphView();
              } else {
                this.app.workspace.openLinkText("", node.file.path);
              }
            });
            circleNodes[j].addEventListener("touchend", () => {
              this.app.workspace.openLinkText("", node.file.path);
            });
            circleNodes[j].addEventListener("contextmenu", (event) => {
              const menu = new import_obsidian12.Menu();
              for (let command of this.plugin.settings.NodeCommands) {
                menu.addItem((item) => item.setTitle(command.name).setIcon(command.icon).onClick(async () => {
                  let copyStr = "";
                  switch (command.copyType) {
                    case 1:
                      copyStr = node.ID;
                      break;
                    case 2:
                      copyStr = node.file.path;
                      break;
                    case 3:
                      copyStr = (0, import_obsidian12.moment)(node.ctime).format(this.plugin.settings.datetimeFormat);
                      break;
                    default:
                      break;
                  }
                  if (copyStr !== "") {
                    await navigator.clipboard.writeText(copyStr);
                  }
                  this.app.commands.executeCommandById(command.id);
                }));
              }
              menu.showAtMouseEvent(event);
            });
            circleNodes[j].addEventListener(`mouseover`, (event) => {
              this.app.workspace.trigger(`hover-link`, {
                event,
                source: ZK_NAVIGATION,
                hoverParent: circleNodes[j],
                linktext: node.file.basename,
                targetEl: circleNodes[j],
                sourcePath: node.file.path
              });
            });
          }
        }
      }
    }
  }
  resetController() {
    this.plugin.tableArr = this.branchAllNodes[this.plugin.settings.BranchTab].branchNodes.sort((a, b) => a.ctime - b.ctime);
    const branchMermaid = document.getElementById(`zk-index-mermaid-${this.plugin.settings.BranchTab}-svg`);
    if (branchMermaid == null)
      return;
    if (this.plugin.settings.graphType === "structure") {
      this.playStatus = {
        current: -1,
        total: this.plugin.tableArr.length,
        nodeGArr: Array.from(branchMermaid.querySelectorAll("[id^='flowchart-']")),
        lines: Array.from(branchMermaid.querySelectorAll(`[id^='L_']`)),
        labels: []
      };
      this.playStatus.nodeGArr.forEach((item) => {
        item.removeClass("zk-hidden");
      });
      this.playStatus.lines.forEach((item) => {
        item.removeClass("zk-hidden");
      });
    } else {
      let nodeGArr = [];
      let lines = [];
      let lables = [];
      const gElements = branchMermaid.querySelectorAll("g.commit-bullets");
      gElements.forEach((gElement) => {
        const circleNodes = gElement.querySelectorAll("circle.commit");
        if (circleNodes.length > 0) {
          nodeGArr = Array.from(circleNodes);
        }
      });
      const aElements = branchMermaid.querySelectorAll("g.commit-arrows");
      aElements.forEach((aElement) => {
        const pathNodes = aElement.querySelectorAll("path.arrow");
        if (pathNodes.length > 0) {
          lines = Array.from(pathNodes);
        }
      });
      const lElements = branchMermaid.querySelectorAll("g.commit-labels");
      lElements.forEach((lElement) => {
        const pathNodes = lElement.querySelectorAll("g");
        if (pathNodes.length > 0) {
          lables = Array.from(pathNodes);
        }
      });
      this.playStatus = {
        current: -1,
        total: this.plugin.tableArr.length,
        nodeGArr,
        lines,
        labels: lables
      };
      this.playStatus.nodeGArr.forEach((item) => {
        item.removeClass("zk-hidden");
      });
      this.playStatus.lines.forEach((item) => {
        item.removeClass("zk-hidden");
      });
      this.playStatus.labels.forEach((item) => {
        item.removeClass("zk-hidden");
      });
    }
  }
  async openBranchTab(tabNo) {
    this.plugin.settings.BranchTab = tabNo;
    const branchGraph = document.getElementsByClassName("zk-index-mermaid");
    const branchTabs = document.getElementsByClassName("zk-branch-tab");
    for (let i = 0; i < branchGraph.length; i++) {
      branchGraph[i].addClass("zk-hidden");
      branchTabs[i].removeClass("zk-branch-tab-select");
    }
    branchGraph[tabNo].removeClass("zk-hidden");
    branchTabs[tabNo].addClass("zk-branch-tab-select");
    if (this.plugin.settings.ListTree === true) {
      this.plugin.tableArr = this.branchAllNodes[this.plugin.settings.BranchTab].branchNodes.sort((a, b) => a.IDStr.localeCompare(b.IDStr));
      this.app.workspace.trigger("zk-navigation:refresh-outline-view");
    }
  }
  async getBranchEntranceNode(lastRetrival) {
    let branchNodeArr = [];
    const indexFile = this.app.vault.getFileByPath(lastRetrival.filePath);
    if (indexFile !== null) {
      const resolvedLinks = this.app.metadataCache.resolvedLinks;
      let frontLinks = Object.keys(resolvedLinks[indexFile.path]).filter((l) => l.endsWith("md"));
      if (frontLinks.length > 0) {
        for (let link of frontLinks) {
          let branchFile = this.app.vault.getFileByPath(link);
          if (branchFile) {
            let nodes = this.plugin.MainNotes.filter((l) => l.file.path == (branchFile == null ? void 0 : branchFile.path));
            if (nodes.length > 0) {
              branchNodeArr.push(...nodes);
            }
          }
        }
      }
      if (this.plugin.settings.lastRetrival.type !== "index" && branchNodeArr.length == 0) {
        new import_obsidian12.Notice(`${t("Index: ")}\u3010${indexFile.basename}\u3011${t("has no valid main note outlinks")}`);
      }
    }
    return branchNodeArr;
  }
  async getBranchNodes(entranceNode) {
    let branchNodes = [];
    let startNode = entranceNode;
    switch (this.plugin.settings.StartingPoint) {
      case "root":
        let frontNodes = this.plugin.MainNotes.filter((n) => entranceNode.IDStr.startsWith(n.IDStr));
        if (frontNodes.length > 0) {
          startNode = frontNodes[0];
        } else {
          new import_obsidian12.Notice("Can't find the root of the branch!");
        }
        branchNodes = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(startNode.IDStr));
        break;
      case "parent":
        if (entranceNode.IDArr.length > 1) {
          let fatherArr = entranceNode.IDArr.slice(0, entranceNode.IDArr.length - 1);
          let fatherNode = this.plugin.MainNotes.find((n) => n.IDStr == fatherArr.toString());
          if (typeof fatherNode !== "undefined") {
            startNode = fatherNode;
          } else {
            startNode = entranceNode;
          }
        } else {
          startNode = entranceNode;
        }
        branchNodes = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(startNode.IDStr)).filter((n) => n.IDStr.startsWith(entranceNode.IDStr) || n.IDArr.length <= entranceNode.IDArr.length);
        break;
      default:
        branchNodes = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(entranceNode.IDStr));
    }
    if (this.plugin.settings.DisplayLevel == "next") {
      branchNodes = branchNodes.filter((n) => !n.IDStr.startsWith(entranceNode.IDStr) || n.IDArr.length <= entranceNode.IDArr.length + 1);
    }
    if (this.plugin.settings.siblingLenToggle === true) {
      const maxLength = Math.max(...branchNodes.map((n) => n.IDArr.length));
      const minLength = Math.min(...branchNodes.map((n) => n.IDArr.length));
      for (let i = minLength; i <= maxLength; i++) {
        let layerNodes = branchNodes.filter((n) => n.IDArr.length === i);
        if (layerNodes.length > 1) {
          let maxTextLen = Math.max(...layerNodes.map((n) => displayWidth(n.displayText)));
          for (let node of layerNodes) {
            node.fixWidth = 6 * maxTextLen + 6;
          }
        } else {
          layerNodes[0].fixWidth = 0;
        }
      }
    }
    return branchNodes;
  }
  async generateGitgraphStr(Nodes, entranceNode, branchTab) {
    this.generateGitBranch(Nodes, branchTab);
    this.order = 0;
    this.result = [];
    let temBranches = this.gitBranches.filter((b) => b.branchName === "main");
    this.gitBranches = this.gitBranches.filter((b) => b.branchName !== "main");
    if (temBranches.length > 0) {
      if (this.plugin.settings.gitUncrossing === true) {
        this.orderGitBranch_uncrossing(temBranches[0]);
      } else {
        this.result = temBranches.concat(this.gitBranches);
      }
      let git = {
        branchTab,
        gitBranches: this.result,
        indexNode: entranceNode
      };
      this.allGitBranch.push(git);
    }
    temBranches = this.result.filter((b) => b.branchName === "main");
    this.gitBranches = this.result.filter((b) => b.branchName !== "main");
    let gitNodePos = 0;
    let gitStr = "";
    while (temBranches.length > 0) {
      let nextBranch = temBranches.reduce((min, obj) => {
        return min && min.nodes[min.currentPos].ctime < obj.nodes[obj.currentPos].ctime ? min : obj;
      }, temBranches[0]);
      let branchIndex = temBranches.indexOf(nextBranch);
      let nextNode = temBranches[branchIndex].nodes[temBranches[branchIndex].currentPos];
      temBranches[branchIndex].currentPos = temBranches[branchIndex].currentPos + 1;
      nextNode.gitNodePos = gitNodePos;
      gitNodePos = gitNodePos + 1;
      if (nextBranch.active === false) {
        gitStr = gitStr + `checkout ${nextBranch.branchPoint.branchName}
`;
        nextBranch.active = true;
      }
      gitStr = gitStr + `checkout ${nextBranch.branchName}
            commit id: "${nextNode == null ? void 0 : nextNode.displayText}"`;
      if ((nextNode == null ? void 0 : nextNode.ID) === entranceNode.ID) {
        gitStr = gitStr + `tag: "index\u{1F33F}"`;
      }
      gitStr = gitStr + `
`;
      if (temBranches[branchIndex].nodes.length === temBranches[branchIndex].currentPos) {
        temBranches.splice(branchIndex, 1);
      }
      let newBranches = this.gitBranches.filter((n) => n.branchPoint.ID == (nextNode == null ? void 0 : nextNode.ID));
      for (let branch of newBranches) {
        temBranches.push(branch);
        gitStr = gitStr + `branch ${branch.branchName} order: ${branch.order}
`;
      }
    }
    let mermaidStr = `%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': false, 'parallelCommits': ${this.plugin.settings.nodeClose}, 'rotateCommitLabel': true}} }%%
                                gitGraph
                                ${gitStr}
                                `;
    return mermaidStr;
  }
  generateGitBranch(Nodes, branchTab) {
    const maxLength = Math.max(...Nodes.map((n) => n.IDArr.length));
    const minLength = Math.min(...Nodes.map((n) => n.IDArr.length));
    this.gitBranches = [];
    this.gitBranches.push({
      branchName: "main",
      branchPoint: Nodes[0],
      nodes: Nodes.filter((l) => l.IDArr.length === minLength),
      currentPos: 0,
      order: 0,
      positionX: 0,
      active: true
    });
    let index = this.branchAllNodes[branchTab].branchNodes.indexOf(Nodes[0]);
    if (index > -1) {
      this.branchAllNodes[branchTab].branchNodes[index].branchName = "main";
    }
    for (let i = minLength; i < maxLength; i++) {
      let layerNodes = Nodes.filter((n) => n.IDArr.length === i);
      for (let fatherNode of layerNodes) {
        let sons = Nodes.filter((n) => n.IDArr.length === i + 1 && n.IDArr.slice(0, -1).toString() === fatherNode.IDStr);
        if (sons.length > 0) {
          let firstSon = sons.reduce((min, obj) => {
            return min && min.ctime < obj.ctime ? min : obj;
          }, sons[0]);
          if (/[0-9]/.test(firstSon.ID.slice(-1))) {
            this.distinguishSons(Nodes, fatherNode, branchTab, i, /[0-9]/);
            this.distinguishSons(Nodes, fatherNode, branchTab, i, /[a-zA-Z]/);
          } else {
            this.distinguishSons(Nodes, fatherNode, branchTab, i, /[a-zA-Z]/);
            this.distinguishSons(Nodes, fatherNode, branchTab, i, /[0-9]/);
          }
        }
      }
    }
  }
  distinguishSons(Nodes, fatherNode, branchTab, i, regExp) {
    let sons = Nodes.filter((n) => n.IDArr.length === i + 1 && regExp.test(n.ID.slice(-1)) && n.IDArr.slice(0, -1).toString() === fatherNode.IDStr);
    if (sons.length > 0) {
      let branchName = `B${this.gitBranches.length}`;
      let gitBranch = {
        branchName,
        branchPoint: fatherNode,
        nodes: sons,
        currentPos: 0,
        positionX: 0,
        order: this.gitBranches.length,
        active: false
      };
      this.gitBranches.push(gitBranch);
      for (let node of sons) {
        let index = this.branchAllNodes[branchTab].branchNodes.indexOf(node);
        this.branchAllNodes[branchTab].branchNodes[index].branchName = branchName;
      }
    }
  }
  orderGitBranch_uncrossing(current) {
    current.order = this.order;
    this.result.push(current);
    this.order = this.order + 1;
    for (let i = current.nodes.length - 1; i >= 0; i--) {
      let branches = this.gitBranches.filter((b) => b.branchPoint.ID === current.nodes[i].ID);
      if (branches.length > 0) {
        branches.sort((a, b) => a.nodes[0].ctime - b.nodes[0].ctime);
        for (let next of branches) {
          this.orderGitBranch_uncrossing(next);
        }
      }
    }
  }
  async generateFlowchartStr(Nodes, entranceNode, direction) {
    let mermaidStr = `%%{ init: { 'flowchart': { 'curve': 'base', 'wrappingWidth': '3000' },
        'themeVariables':{ 'fontSize': '12px'}}}%% flowchart ${direction};
`;
    for (let node of Nodes) {
      if (this.plugin.settings.siblingLenToggle === true && node.fixWidth !== 0) {
        mermaidStr = mermaidStr + `${node.position}("<p style='width:${node.fixWidth}px;'>${node.displayText}</p>");
`;
      } else {
        mermaidStr = mermaidStr + `${node.position}("${node.displayText}");`;
      }
      if (node.IDStr.startsWith(entranceNode.IDStr)) {
        mermaidStr = mermaidStr + `style ${node.position} fill:${this.plugin.settings.nodeColor},stroke:#333,stroke-width:1px 
`;
      } else {
        mermaidStr = mermaidStr + `style ${node.position} fill:#fff; 
`;
      }
    }
    for (let node of Nodes) {
      let sonNodes = Nodes.filter((n) => n.IDArr.length - 1 == node.IDArr.length && n.IDStr.startsWith(node.IDStr) && n.ID.startsWith(node.ID));
      for (let son of sonNodes) {
        mermaidStr = mermaidStr + `${node.position} --> ${son.position};
`;
      }
    }
    if (this.plugin.settings.RedDashLine === true) {
      for (let node of Nodes) {
        if (/^[a-zA-Z]$/.test(node.ID.slice(-1))) {
          mermaidStr = mermaidStr + `style ${node.position} stroke:#f66,stroke-width:2px,stroke-dasharray: 1 
`;
        }
      }
    }
    return mermaidStr;
  }
  unshiftHistoryList(lastRetrival) {
    let a = this.plugin.settings.HistoryList.find((n) => n.type == lastRetrival.type && n.filePath == lastRetrival.filePath && n.ID == lastRetrival.ID);
    if (a) {
      let index = this.plugin.settings.HistoryList.indexOf(a);
      if (index > -1) {
        this.plugin.settings.HistoryList.splice(index, 1);
      }
    }
    lastRetrival.openTime = (0, import_obsidian12.moment)().format("YYYY-MM-DD HH:mm:ss");
    this.plugin.settings.HistoryList.unshift(lastRetrival);
    if (this.plugin.settings.HistoryList.length > this.plugin.settings.HistoryMaxCount) {
      this.plugin.settings.HistoryList = this.plugin.settings.HistoryList.slice(0, this.plugin.settings.HistoryMaxCount);
    }
  }
  async generateCanvasStr() {
    var _a;
    let nodes = (_a = this.branchAllNodes.find((b) => b.branchTab == this.plugin.settings.BranchTab)) == null ? void 0 : _a.branchNodes;
    if (typeof nodes === "undefined")
      return;
    nodes.sort((a, b) => a.IDStr.localeCompare(b.IDStr));
    let cardWidth = this.plugin.settings.cardWidth;
    let cardHeight = this.plugin.settings.cardHeight;
    let intervalX = cardWidth / 2;
    let intervalY = cardHeight / 8;
    let fromSide = "right";
    let toSide = "left";
    let direction = this.plugin.settings.DirectionOfBranchGraph;
    switch (direction) {
      case "RL":
        cardWidth = -cardWidth;
        cardHeight = cardHeight;
        intervalX = cardWidth / 2;
        intervalY = cardHeight / 8;
        fromSide = "left";
        toSide = "right";
        break;
      case "TB":
        cardWidth = cardWidth;
        cardHeight = cardHeight;
        intervalX = cardHeight / 8;
        intervalY = cardWidth / 2;
        fromSide = "bottom";
        toSide = "top";
        break;
      case "BT":
        cardWidth = -cardWidth;
        cardHeight = cardHeight;
        intervalX = -cardHeight / 8;
        intervalY = -cardWidth / 2;
        fromSide = "top";
        toSide = "bottom";
        break;
      default:
        break;
    }
    const maxLength = Math.max(...nodes.map((n) => n.IDArr.length));
    const minLength = Math.min(...nodes.map((n) => n.IDArr.length));
    for (let i = maxLength - 1; i >= minLength; i--) {
      let layerNodes = nodes.filter((n) => n.IDArr.length === i);
      for (let node of layerNodes) {
        let sons = nodes.filter((n) => n.IDStr.startsWith(node.IDStr) && n.IDArr.length == i + 1);
        if (sons.length > 0) {
          let target = nodes.indexOf(node);
          if (target >= 0) {
            nodes[target].nodeSons = sons.reduce((count, node2) => count + node2.nodeSons, 0);
          }
        } else {
          node.nodeSons = 1;
        }
      }
    }
    for (let i = minLength; i <= maxLength; i++) {
      let layerNodes = nodes.filter((n) => n.IDArr.length === i);
      let deep = 0;
      for (let j = 0; j < layerNodes.length; j++) {
        let father = nodes.find((n) => layerNodes[j].IDStr.startsWith(n.IDStr) && n.IDArr.length === i - 1);
        if (typeof father !== "undefined") {
          layerNodes[j].startY = father.startY + deep;
          let height = intervalY * (layerNodes[j].nodeSons - 1) + cardHeight * layerNodes[j].nodeSons;
          layerNodes[j].height = father.startY + deep + height / 2;
          deep = deep + height + intervalY;
          if (j < layerNodes.length - 1) {
            let nextFather = nodes.find((n) => layerNodes[j + 1].IDStr.startsWith(n.IDStr) && n.IDArr.length === i - 1);
            if (typeof nextFather !== "undefined" && father !== nextFather) {
              deep = 0;
            }
          }
        } else {
          layerNodes[j].height = (intervalY * (layerNodes[j].nodeSons - 1) + cardHeight * layerNodes[j].nodeSons) / 2;
        }
      }
    }
    this.tightCards(nodes, intervalY, cardHeight);
    let canvasNodeStr = "";
    let canvasEdgeStr = "";
    for (let i = 0; i < nodes.length; i++) {
      let positionX = (nodes[i].IDArr.length - nodes[0].IDArr.length) * (cardWidth + intervalX);
      let positionY = nodes[i].height;
      if (direction === "LR" || direction === "RL") {
        canvasNodeStr = canvasNodeStr + `
                {"id":"${nodes[i].randomId}","x":${positionX},"y":${positionY},"width":${Math.abs(cardWidth)},"height":${Math.abs(cardHeight)},"type":"file","file":"${nodes[i].file.path}"},`;
      } else {
        canvasNodeStr = canvasNodeStr + `
                {"id":"${nodes[i].randomId}","x":${positionY},"y":${positionX},"width":${Math.abs(cardWidth)},"height":${Math.abs(cardHeight)},"type":"file","file":"${nodes[i].file.path}"},`;
      }
      let IDStr = nodes[i].IDStr;
      let IDArr = nodes[i].IDArr;
      let sonNodes = nodes.filter((n) => n.IDStr.startsWith(IDStr) && n.IDArr.length == IDArr.length + 1);
      for (let son of sonNodes) {
        canvasEdgeStr = canvasEdgeStr + `
                {"id":"${random(16)}","fromNode":"${nodes[i].randomId}","fromSide":"${fromSide}","toNode":"${son.randomId}","toSide":"${toSide}"},`;
      }
    }
    if (canvasNodeStr.length > 0) {
      canvasNodeStr = canvasNodeStr.slice(0, -1);
    }
    if (canvasEdgeStr.length > 0) {
      canvasEdgeStr = canvasEdgeStr.slice(0, -1);
    }
    this.fileContent = `{
        "nodes":[${canvasNodeStr}
        ],
        "edges":[${canvasEdgeStr}
	    ]
        }`;
  }
  tightCards(nodes, intervalY, cardHeight) {
    const maxLength = Math.max(...nodes.map((n) => n.IDArr.length));
    const minLength = Math.min(...nodes.map((n) => n.IDArr.length));
    for (let i = maxLength - 1; i >= minLength; i--) {
      let layerNodes = nodes.filter((n) => n.IDArr.length === i);
      for (let node of layerNodes) {
        let sons = nodes.filter((n) => n.IDStr.startsWith(node.IDStr) && n.IDArr.length == i + 1);
        if (sons.length > 1) {
          let upSons = sons.filter((n) => n.height + cardHeight < node.height + (cardHeight + intervalY) / 2);
          for (let j = upSons.length - 1; j >= 0; j--) {
            let gapYArr = [];
            let sequentNodes = nodes.filter((n) => n.IDStr.startsWith(upSons[j].IDStr));
            let maxLen = Math.max(...sequentNodes.map((n) => n.IDArr.length));
            for (let k = upSons[j].IDArr.length; k <= maxLen; k++) {
              let temLayerNodes = sequentNodes.filter((n) => n.IDArr.length === k);
              let maxHeightNode = temLayerNodes.find((n) => n.height == Math.max(...temLayerNodes.map((n2) => n2.height)));
              if (typeof maxHeightNode !== "undefined") {
                let columnNodes = nodes.filter((n) => n.IDArr.length === k);
                let nextNodeIndex = columnNodes.indexOf(maxHeightNode) + 1;
                let nextNode = columnNodes[nextNodeIndex];
                if (typeof nextNode !== "undefined") {
                  let gapY = nextNode.height - maxHeightNode.height - cardHeight;
                  if (gapY >= intervalY) {
                    gapYArr.push(gapY);
                  }
                }
              }
            }
            if (gapYArr.length > 0) {
              if (j == upSons.length - 1) {
                let firstGapY = node.height + (cardHeight + intervalY) / 2 - upSons[upSons.length - 1].height - cardHeight;
                if (firstGapY > intervalY) {
                  gapYArr.push(firstGapY);
                } else {
                  continue;
                }
                gapYArr.push(firstGapY);
              }
              let minGapY = Math.min(...gapYArr);
              if (minGapY > intervalY) {
                for (let item of sequentNodes) {
                  nodes[nodes.indexOf(item)].height += minGapY - intervalY;
                }
              }
            }
          }
          let bottomSons = sons.filter((n) => n.height > node.height + (cardHeight + intervalY) / 2);
          for (let j = 0; j < bottomSons.length; j++) {
            let gapYArr = [];
            let sequentNodes = nodes.filter((n) => n.IDStr.startsWith(bottomSons[j].IDStr));
            let maxLen = Math.max(...sequentNodes.map((n) => n.IDArr.length));
            for (let k = bottomSons[j].IDArr.length; k <= maxLen; k++) {
              let temLayerNodes = sequentNodes.filter((n) => n.IDArr.length === k);
              let minHeightNode = temLayerNodes.find((n) => n.height == Math.min(...temLayerNodes.map((n2) => n2.height)));
              if (typeof minHeightNode !== "undefined") {
                let columnNodes = nodes.filter((n) => n.IDArr.length === k);
                let previousNodeIndex = columnNodes.indexOf(minHeightNode) - 1;
                let previousNode = columnNodes[previousNodeIndex];
                if (typeof previousNode !== "undefined") {
                  let gapY = minHeightNode.height - previousNode.height - cardHeight;
                  if (gapY >= intervalY) {
                    gapYArr.push(gapY);
                  }
                }
              }
            }
            if (gapYArr.length > 0) {
              if (j == 0) {
                let firstGapY = bottomSons[0].height - node.height - (cardHeight - intervalY) / 2;
                if (firstGapY > intervalY) {
                  gapYArr.push(firstGapY);
                } else {
                  continue;
                }
                gapYArr.push(firstGapY);
              }
              let minGapY = Math.min(...gapYArr);
              if (minGapY > intervalY) {
                for (let item of sequentNodes) {
                  nodes[nodes.indexOf(item)].height -= minGapY - intervalY;
                }
              }
            }
          }
        }
      }
    }
  }
  async generateCanvasStrGit() {
    const cardWidth = this.plugin.settings.cardWidth;
    const cardHeight = this.plugin.settings.cardHeight;
    const intervalX = cardWidth / 4;
    const intervalY = cardHeight / 4;
    let gitBranches = this.allGitBranch.filter((n) => n.branchTab === this.plugin.settings.BranchTab)[0].gitBranches;
    gitBranches.sort((a, b) => a.order - b.order);
    for (let i = 1; i < gitBranches.length; i++) {
      for (let j = i - 1; j >= 0; j--) {
        let node = gitBranches[j].nodes.find((n) => n.ID === gitBranches[i].branchPoint.ID);
        if (node !== void 0) {
          let index = gitBranches[j].nodes.indexOf(node);
          gitBranches[i].positionX = gitBranches[j].positionX + (cardWidth + intervalX) * (index + 1);
          break;
        }
      }
    }
    let canvasNodeStr = "";
    let canvasEdgeStr = "";
    for (let branch of gitBranches) {
      for (let i = 0; i < branch.nodes.length; i++) {
        canvasNodeStr = canvasNodeStr + `
                {"id":"${branch.nodes[i].randomId}","x":${branch.positionX + (cardWidth + intervalX) * i},"y":${(cardHeight + intervalY) * branch.order},"width":${cardWidth},"height":${cardHeight},"type":"file","file":"${branch.nodes[i].file.path}"},`;
      }
      for (let i = 1; i < branch.nodes.length; i++) {
        canvasEdgeStr = canvasEdgeStr + `
                {"id":"${random(16)}","fromNode":"${branch.nodes[i - 1].randomId}","fromSide":"right","toNode":"${branch.nodes[i].randomId}","toSide":"left"},`;
      }
      if (gitBranches.indexOf(branch) > 0) {
        canvasEdgeStr = canvasEdgeStr + `
                {"id":"${random(16)}","fromNode":"${branch.branchPoint.randomId}","fromSide":"bottom","toNode":"${branch.nodes[0].randomId}","toSide":"left"},`;
      }
    }
    if (canvasNodeStr.length > 0) {
      canvasNodeStr = canvasNodeStr.slice(0, -1);
    }
    if (canvasEdgeStr.length > 0) {
      canvasEdgeStr = canvasEdgeStr.slice(0, -1);
    }
    this.fileContent = `{
        "nodes":[${canvasNodeStr}
        ],
        "edges":[${canvasEdgeStr}
	    ]
        }`;
  }
  async exportToCanvas() {
    let targetfile;
    let filePath = "";
    if (this.plugin.settings.canvasFilePath.endsWith(".canvas")) {
      filePath = this.plugin.settings.canvasFilePath;
      targetfile = this.app.vault.getAbstractFileByPath(filePath);
      if (targetfile && targetfile instanceof import_obsidian12.TFile) {
        await this.app.vault.modify(targetfile, this.fileContent);
      }
    }
    if (!(targetfile instanceof import_obsidian12.TFile)) {
      if (filePath == "") {
        filePath = `${(0, import_obsidian12.moment)().format("YYYY-MM-DD HH.mm.ss")}.canvas`;
      }
      new import_obsidian12.Notice("create new canvas file: " + filePath);
      targetfile = await this.app.vault.create(filePath, this.fileContent);
    }
    if (targetfile instanceof import_obsidian12.TFile) {
      let leaf = this.app.workspace.getLeavesOfType("canvas").filter((l) => l.getDisplayText() == targetfile.basename);
      if (leaf.length > 0) {
        this.app.workspace.revealLeaf(leaf[0]);
      } else {
        this.app.workspace.openLinkText("", targetfile.path);
      }
    }
    this.fileContent = "";
  }
  async branchGrowing() {
    await this.hideBranchElements();
    let sec = 500;
    for (let node of this.plugin.tableArr) {
      setTimeout(() => {
        let nodeG = this.playStatus.nodeGArr.find((n) => n.id.startsWith(`flowchart-${node.position}`));
        if (nodeG) {
          nodeG.removeClass("zk-hidden");
        }
        let line = this.playStatus.lines.find((n) => n.id.split("_")[2] == node.position.toString());
        if (line) {
          line.removeClass("zk-hidden");
        }
      }, sec);
      sec = sec + 500;
    }
  }
  async branchGrowingGit() {
    await this.hideBranchElements();
    let sec = 500;
    for (let i = 0; i < this.playStatus.nodeGArr.length; i++) {
      setTimeout(() => {
        this.playStatus.current = i;
        this.branchPlayingGit();
      }, sec);
      sec = sec + 500;
    }
  }
  async hideBranchElements() {
    this.playStatus.nodeGArr.forEach((item) => {
      item.addClass("zk-hidden");
    });
    this.playStatus.lines.forEach((item) => {
      item.addClass("zk-hidden");
    });
    this.playStatus.labels.forEach((item) => {
      item.addClass("zk-hidden");
    });
    await this.toggleTagGit(true);
  }
  async branchPlaying() {
    let split = this.playStatus.current + 1;
    let showNodes = this.plugin.tableArr.slice(0, split);
    let hideNodes = this.plugin.tableArr.slice(split);
    for (let node of showNodes) {
      let nodeG = this.playStatus.nodeGArr.find((n) => n.id.startsWith(`flowchart-${node.position}`));
      if (nodeG) {
        nodeG.removeClass("zk-hidden");
      }
      let line = this.playStatus.lines.find((n) => n.id.split("_")[2] == node.position.toString());
      if (line) {
        line.removeClass("zk-hidden");
      }
    }
    for (let node of hideNodes) {
      let nodeG = this.playStatus.nodeGArr.find((n) => n.id.startsWith(`flowchart-${node.position}`));
      if (nodeG) {
        nodeG.addClass("zk-hidden");
      }
      let line = this.playStatus.lines.find((n) => n.id.split("_")[2] == node.position.toString());
      if (line) {
        line.addClass("zk-hidden");
      }
    }
  }
  async branchPlayingGit() {
    let split = this.playStatus.current + 1;
    for (let el of this.playStatus.nodeGArr.slice(0, split)) {
      el.removeClass("zk-hidden");
    }
    for (let el of this.playStatus.lines.slice(0, split - 1)) {
      el.removeClass("zk-hidden");
    }
    for (let el of this.playStatus.labels.slice(0, split)) {
      el.removeClass("zk-hidden");
    }
    for (let el of this.playStatus.nodeGArr.slice(split)) {
      el.addClass("zk-hidden");
    }
    for (let el of this.playStatus.lines.slice(split - 1)) {
      el.addClass("zk-hidden");
    }
    for (let el of this.playStatus.labels.slice(split)) {
      el.addClass("zk-hidden");
    }
    let indexPos = this.allGitBranch[this.plugin.settings.BranchTab].indexNode.gitNodePos;
    if (indexPos >= split) {
      await this.toggleTagGit(true);
    } else {
      await this.toggleTagGit(false);
    }
  }
  async toggleTagGit(toggle) {
    const indexMermaid = document.getElementById(`zk-index-mermaid-${this.plugin.settings.BranchTab}`);
    if (!indexMermaid)
      return;
    let polygonEls = indexMermaid.querySelectorAll("polygon");
    if (polygonEls.length > 0) {
      if (toggle) {
        let nextEl1 = polygonEls[0].nextElementSibling;
        polygonEls[0].addClass("zk-hidden");
        if (nextEl1) {
          nextEl1.addClass("zk-hidden");
          let nextEl2 = nextEl1.nextElementSibling;
          if (nextEl2) {
            nextEl2.addClass("zk-hidden");
          }
        }
      } else {
        let nextEl1 = polygonEls[0].nextElementSibling;
        polygonEls[0].removeClass("zk-hidden");
        if (nextEl1) {
          nextEl1.removeClass("zk-hidden");
          let nextEl2 = nextEl1.nextElementSibling;
          if (nextEl2) {
            nextEl2.removeClass("zk-hidden");
          }
        }
      }
    }
  }
  async addFoldIcon(indexMermaid) {
    const rects = indexMermaid.getElementsByTagName("rect");
    let rectArr = [];
    Array.from(rects).forEach((item) => {
      if (item.classList.contains("label-container")) {
        rectArr.push(item);
      }
    });
    rectArr.forEach((item) => {
      const circleX = Number(item.getAttr("x")) + Number(item.getAttr("width"));
      const circleY = Number(item.getAttr("y")) + Number(item.getAttr("height")) / 2;
      const newCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      newCircle.setAttr("cx", circleX);
      newCircle.setAttr("cy", circleY);
      newCircle.setAttr("r", 8);
      if (item.parentElement) {
        let nodePosStr = item.parentElement.id.split("-")[1];
        let node = this.plugin.MainNotes.filter((n) => n.position == Number(nodePosStr))[0];
        if (this.plugin.settings.FoldNodeArr.filter((n) => n.nodeIDstr == node.IDStr && (n.graphID = indexMermaid.id)).length === 0) {
          newCircle.addClass("zk-fold-yellow");
        } else {
          newCircle.addClass("zk-fold-green");
        }
        item.parentElement.insertAfter(newCircle, item.nextSibling);
        newCircle.addEventListener("click", async (event) => {
          const clickNode = {
            graphID: indexMermaid.id,
            nodeIDstr: node.IDStr,
            position: node.position
          };
          if (this.plugin.settings.FoldNodeArr.filter((n) => n.nodeIDstr == node.IDStr && (n.graphID = indexMermaid.id)).length === 0) {
            this.plugin.settings.FoldNodeArr.push(clickNode);
          } else {
            let index = this.plugin.settings.FoldNodeArr.findIndex((item2) => item2.graphID === clickNode.graphID && item2.nodeIDstr === clickNode.nodeIDstr);
            if (index !== -1) {
              this.plugin.settings.FoldNodeArr.splice(index, 1);
            }
          }
          if (event.ctrlKey && newCircle.hasClass("zk-fold-green")) {
            this.plugin.settings.FoldNodeArr = this.plugin.settings.FoldNodeArr.filter((n) => !n.nodeIDstr.startsWith(clickNode.nodeIDstr));
          }
          event.stopPropagation();
          await this.refreshBranchMermaid();
        });
        newCircle.addEventListener("touchend", async (event) => {
          const clickNode = {
            graphID: indexMermaid.id,
            nodeIDstr: node.IDStr,
            position: node.position
          };
          if (this.plugin.settings.FoldNodeArr.filter((n) => n.nodeIDstr == node.IDStr && (n.graphID = indexMermaid.id)).length === 0) {
            this.plugin.settings.FoldNodeArr.push(clickNode);
          } else {
            let index = this.plugin.settings.FoldNodeArr.findIndex((item2) => item2.graphID === clickNode.graphID && item2.nodeIDstr === clickNode.nodeIDstr);
            if (index !== -1) {
              this.plugin.settings.FoldNodeArr.splice(index, 1);
            }
          }
          event.stopPropagation();
          await this.refreshBranchMermaid();
        });
      }
    });
  }
  async onClose() {
    this.plugin.saveData(this.plugin.settings);
  }
};

// src/modal/expandGraphModal.ts
var import_obsidian13 = require("obsidian");
var expandGraphModal = class extends import_obsidian13.Modal {
  constructor(app, plugin, mainNotes, files, mermaidStr) {
    super(app);
    this.plugin = plugin;
    this.mainNotes = mainNotes;
    this.mermaidStr = mermaidStr;
    this.files = files;
  }
  async onOpen() {
    let { contentEl } = this;
    this.modalEl.addClass("zk-expand-modal");
    const mermaid = await (0, import_obsidian13.loadMermaid)();
    const svgGraph = contentEl.createEl("div", { cls: "zk-expand-graph" });
    svgGraph.id = "zk-expand-graph";
    let { svg } = await mermaid.render(`zk-expand-graph-svg`, `${this.mermaidStr}`);
    svgGraph.insertAdjacentHTML("beforeend", svg);
    svgGraph.children[0].removeAttribute("style");
    svgGraph.children[0].addClass("zk-full-width");
    svgGraph.children[0].setAttribute("height", `${this.modalEl.offsetHeight - 50}px`);
    this.contentEl.appendChild(svgGraph);
    const svgPanZoom = require_browserify();
    let panZoomTiger = svgPanZoom(`#zk-expand-graph-svg`, {
      zoomEnabled: true,
      controlIconsEnabled: false,
      fit: false,
      center: true,
      minZoom: 1e-3,
      maxZoom: 1e3,
      dblClickZoomEnabled: false,
      zoomScaleSensitivity: 0.25
    });
    let setSvg = document.getElementById(`${svgGraph.id}-svg`);
    if (setSvg !== null) {
      let a = setSvg.children[0].getAttr("style");
      if (typeof a == "string") {
        let b = a.match(/\d([^\,]+)\d/g);
        if (b !== null && Number(b[0]) > 1) {
          panZoomTiger.zoom(1 / Number(b[0]));
        }
      }
    }
    let nodeGArr = svgGraph.querySelectorAll("[id^='flowchart-']");
    let nodeArr = svgGraph.getElementsByClassName("nodeLabel");
    for (let i = 0; i < nodeArr.length; i++) {
      let link = document.createElement("a");
      link.addClass("internal-link");
      let nodePosStr = nodeGArr[i].id.split("-")[1];
      let path = "";
      if (this.files.length == 0) {
        path = this.mainNotes.filter((n) => n.position == Number(nodePosStr))[0].file.path;
      } else {
        path = this.files[Number(nodePosStr)].path;
      }
      link.textContent = nodeArr[i].getText();
      nodeArr[i].textContent = "";
      nodeArr[i].appendChild(link);
      nodeGArr[i].addEventListener("click", (event) => {
        if (event.ctrlKey) {
          this.app.workspace.openLinkText("", path, "tab");
        } else if (event.shiftKey) {
          this.plugin.retrivalforLocaLgraph = {
            type: "1",
            ID: "",
            filePath: path
          };
          this.plugin.openGraphView();
        } else if (event.altKey) {
          let mainNotes = this.plugin.MainNotes.filter((n) => n.file.path == path);
          if (mainNotes.length > 0) {
            this.plugin.clearShowingSettings();
            this.plugin.settings.lastRetrival = {
              type: "main",
              ID: mainNotes[0].ID,
              displayText: mainNotes[0].displayText,
              filePath: mainNotes[0].file.path,
              openTime: ""
            };
            this.plugin.RefreshIndexViewFlag = true;
            this.app.workspace.trigger("zk-navigation:refresh-index-graph");
          }
        } else {
          this.app.workspace.openLinkText("", path);
        }
      });
      nodeArr[i].addEventListener(`mouseover`, (event) => {
        this.app.workspace.trigger(`hover-link`, {
          event,
          source: ZK_NAVIGATION,
          hoverParent: this,
          linktext: "",
          targetEl: link,
          sourcePath: path
        });
      });
    }
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/view/graphView.ts
var ZK_GRAPH_TYPE = "zk-graph-type";
var ZK_GRAPH_VIEW = t("zk-local-graph");
var ZKGraphView = class extends import_obsidian14.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.familyNodeArr = [];
    this.graphHeight = 0;
    this.countOfGraphs = 0;
    this.gitBranches = [];
    this.refreshLocalGraph = async () => {
      let { containerEl } = this;
      containerEl.empty();
      this.countGraphs();
      this.graphHeight = Math.floor(containerEl.offsetHeight / this.countOfGraphs - 10);
      const graphMermaidDiv = containerEl.createDiv().createDiv("zk-graph-mermaid-container");
      await mainNoteInit(this.plugin);
      switch (this.plugin.retrivalforLocaLgraph.type) {
        case "1":
          this.currentFile = this.app.vault.getFileByPath(this.plugin.retrivalforLocaLgraph.filePath);
          break;
        default:
          this.currentFile = this.app.workspace.getActiveFile();
          if (this.currentFile !== null) {
            let path = this.currentFile.path;
            let nodes = this.familyNodeArr.filter((n) => n.file.path == path);
            if (nodes.length > 0) {
              this.plugin.retrivalforLocaLgraph.ID = nodes[0].ID;
            } else {
              nodes = this.plugin.MainNotes.filter((n) => n.file.path == path);
              if (nodes.length > 0) {
                this.plugin.retrivalforLocaLgraph.ID = nodes[0].ID;
              }
            }
            this.plugin.retrivalforLocaLgraph.filePath = path;
          }
          break;
      }
      graphMermaidDiv.empty();
      if (this.currentFile !== null) {
        const mermaid = await (0, import_obsidian14.loadMermaid)();
        const svgPanZoom = require_browserify();
        if (this.plugin.settings.FamilyGraphToggle == true) {
          await this.getFamilyNodes(this.currentFile);
          if (this.familyNodeArr.length > 0) {
            if (this.plugin.settings.graphType === "structure") {
              let familyMermaidStr = await this.genericFamilyMermaidStr(this.currentFile, this.plugin.settings.DirectionOfFamilyGraph);
              const familyGraphContainer = graphMermaidDiv.createDiv("zk-family-graph-container");
              const familyGraphTextDiv = familyGraphContainer.createDiv("zk-graph-text");
              familyGraphTextDiv.empty();
              familyGraphTextDiv.createEl("span", { text: t("close relative") });
              let graphIconDiv = familyGraphContainer.createDiv("zk-graph-icon");
              graphIconDiv.empty();
              let expandBtn = new import_obsidian14.ExtraButtonComponent(graphIconDiv);
              expandBtn.setIcon("expand").setTooltip(t("expand graph"));
              expandBtn.onClick(() => {
                new expandGraphModal(this.app, this.plugin, this.familyNodeArr, [], familyMermaidStr).open();
              });
              const familyTreeDiv = familyGraphContainer.createEl("div", { cls: "zk-graph-mermaid" });
              familyTreeDiv.id = "zk-family-tree";
              let { svg } = await mermaid.render(`${familyTreeDiv.id}-svg`, `${familyMermaidStr}`);
              familyTreeDiv.insertAdjacentHTML("beforeend", svg);
              familyTreeDiv.children[0].addClass("zk-full-width");
              familyTreeDiv.children[0].setAttribute("height", `${this.graphHeight}px`);
              graphMermaidDiv.appendChild(familyTreeDiv);
              let panZoomTiger = svgPanZoom(`#${familyTreeDiv.id}-svg`, {
                zoomEnabled: true,
                controlIconsEnabled: false,
                fit: false,
                center: true,
                minZoom: 1e-3,
                maxZoom: 1e3,
                dblClickZoomEnabled: false,
                zoomScaleSensitivity: 0.3
              });
              let setSvg = document.getElementById(`${familyTreeDiv.id}-svg`);
              if (setSvg !== null) {
                let a = setSvg.children[0].getAttr("style");
                if (typeof a == "string") {
                  let b = a.match(/\d([^\,]+)\d/g);
                  if (b !== null && Number(b[0]) > 1) {
                    panZoomTiger.zoom(1 / Number(b[0]));
                  }
                }
              }
              let nodeGArr = familyTreeDiv.querySelectorAll("[id^='flowchart-']");
              let nodeArr = familyTreeDiv.getElementsByClassName("nodeLabel");
              for (let i = 0; i < nodeArr.length; i++) {
                let link = document.createElement("a");
                link.addClass("internal-link");
                let nodePosStr = nodeGArr[i].id.split("-")[1];
                let node = this.familyNodeArr.filter((n) => n.position == Number(nodePosStr))[0];
                link.textContent = nodeArr[i].getText();
                nodeArr[i].textContent = "";
                nodeArr[i].appendChild(link);
                nodeGArr[i].addEventListener("click", (event) => {
                  if (event.ctrlKey) {
                    this.app.workspace.openLinkText("", node.file.path, "tab");
                  } else if (event.shiftKey) {
                    this.plugin.retrivalforLocaLgraph = {
                      type: "1",
                      ID: node.ID,
                      filePath: node.file.path
                    };
                    this.plugin.openGraphView();
                  } else if (event.altKey) {
                    this.plugin.clearShowingSettings();
                    this.plugin.settings.lastRetrival = {
                      type: "main",
                      ID: node.ID,
                      displayText: node.displayText,
                      filePath: node.file.path,
                      openTime: ""
                    };
                    this.plugin.RefreshIndexViewFlag = true;
                    this.plugin.openIndexView();
                  } else {
                    this.app.workspace.openLinkText("", node.file.path);
                  }
                });
                nodeGArr[i].addEventListener("touchend", () => {
                  this.app.workspace.openLinkText("", node.file.path);
                });
                nodeGArr[i].addEventListener(`mouseover`, (event) => {
                  this.app.workspace.trigger(`hover-link`, {
                    event,
                    source: ZK_NAVIGATION,
                    hoverParent: this,
                    linktext: "",
                    targetEl: link,
                    sourcePath: node.file.path
                  });
                });
              }
            } else {
              let familyMermaidStr = await this.genericGitgraphStr(this.currentFile);
              const familyGraphContainer = graphMermaidDiv.createDiv("zk-family-graph-container");
              const familyGraphTextDiv = familyGraphContainer.createDiv("zk-graph-text");
              familyGraphTextDiv.empty();
              familyGraphTextDiv.createEl("span", { text: t("close relative") });
              let graphIconDiv = familyGraphContainer.createDiv("zk-graph-icon");
              graphIconDiv.empty();
              let expandBtn = new import_obsidian14.ExtraButtonComponent(graphIconDiv);
              expandBtn.setIcon("expand").setTooltip(t("expand graph"));
              expandBtn.onClick(() => {
                new expandGraphModal(this.app, this.plugin, this.familyNodeArr, [], familyMermaidStr).open();
              });
              const familyTreeDiv = familyGraphContainer.createEl("div", { cls: "zk-graph-mermaid" });
              familyTreeDiv.id = "zk-family-tree";
              let { svg } = await mermaid.render(`${familyTreeDiv.id}-svg`, `${familyMermaidStr}`);
              familyTreeDiv.insertAdjacentHTML("beforeend", svg);
              familyTreeDiv.children[0].removeAttribute("style");
              familyTreeDiv.children[0].addClass("zk-full-width");
              familyTreeDiv.children[0].setAttribute("height", `${this.graphHeight}px`);
              graphMermaidDiv.appendChild(familyTreeDiv);
              let panZoomTiger = svgPanZoom(`#${familyTreeDiv.id}-svg`, {
                zoomEnabled: true,
                controlIconsEnabled: false,
                fit: false,
                center: true,
                minZoom: 1e-3,
                maxZoom: 1e3,
                dblClickZoomEnabled: false,
                zoomScaleSensitivity: 0.3
              });
              let setSvg = document.getElementById(`${familyTreeDiv.id}-svg`);
              if (setSvg !== null) {
                let a = setSvg.children[0].getAttr("style");
                if (typeof a == "string") {
                  let b = a.match(/\d([^\,]+)\d/g);
                  if (b !== null && Number(b[0]) > 1) {
                    panZoomTiger.zoom(1 / Number(b[0]));
                  }
                }
              }
              const gElements = familyTreeDiv.querySelectorAll("g.commit-bullets");
              let temNode = gElements[1];
              const circles = gElements[1].querySelectorAll("circle.commit");
              const circleNodes = Array.from(circles);
              gElements[1].textContent = "";
              for (let j = 0; j < circleNodes.length; j++) {
                let link = document.createElementNS("http://www.w3.org/2000/svg", "a");
                link.appendChild(circleNodes[j]);
                gElements[1].appendChild(link);
                let nodes = this.familyNodeArr;
                let nodeArr = nodes.filter((n) => n.gitNodePos === j);
                if (nodeArr.length > 0) {
                  let node = nodeArr[0];
                  circleNodes[j].addEventListener("click", async (event) => {
                    if (event.ctrlKey) {
                      this.app.workspace.openLinkText("", node.file.path, "tab");
                    } else if (event.shiftKey) {
                      this.plugin.retrivalforLocaLgraph = {
                        type: "1",
                        ID: node.ID,
                        filePath: node.file.path
                      };
                      this.plugin.openGraphView();
                    } else if (event.altKey) {
                      this.plugin.settings.lastRetrival = {
                        type: "main",
                        ID: node.ID,
                        displayText: node.displayText,
                        filePath: node.file.path,
                        openTime: ""
                      };
                      this.plugin.RefreshIndexViewFlag = true;
                      this.plugin.openIndexView();
                    } else {
                      this.app.workspace.openLinkText("", node.file.path);
                    }
                  });
                  circleNodes[j].addEventListener("touchend", () => {
                    this.app.workspace.openLinkText("", node.file.path);
                  });
                  circleNodes[j].addEventListener(`mouseover`, (event) => {
                    this.app.workspace.trigger(`hover-link`, {
                      event,
                      source: ZK_NAVIGATION,
                      hoverParent: circleNodes[j],
                      linktext: node.file.basename,
                      targetEl: circleNodes[j],
                      sourcePath: node.file.path
                    });
                  });
                }
              }
            }
          } else {
            this.countOfGraphs--;
            this.graphHeight = Math.floor(containerEl.offsetHeight / this.countOfGraphs - 10);
          }
        }
        if (this.plugin.settings.InlinksGraphToggle == true) {
          let inlinkArr = await this.getInlinks(this.currentFile);
          let inlinkMermaidStr = await this.genericLinksMermaidStr(this.currentFile, inlinkArr, "in", this.plugin.settings.DirectionOfInlinksGraph);
          const inlinksGraphContainer = graphMermaidDiv.createDiv("zk-inlinks-graph-container");
          const inlinksGraphTextDiv = inlinksGraphContainer.createDiv("zk-graph-text");
          inlinksGraphTextDiv.empty();
          inlinksGraphTextDiv.createEl("span", { text: t("inlinks") });
          let graphIconDiv = inlinksGraphContainer.createDiv("zk-graph-icon");
          graphIconDiv.empty();
          let expandBtn = new import_obsidian14.ExtraButtonComponent(graphIconDiv);
          expandBtn.setIcon("expand").setTooltip(t("expand graph"));
          expandBtn.onClick(() => {
            new expandGraphModal(this.app, this.plugin, [], inlinkArr, inlinkMermaidStr).open();
          });
          const inlinksDiv = inlinksGraphContainer.createEl("div", { cls: "zk-graph-mermaid" });
          inlinksDiv.id = "zk-inlinks";
          let { svg } = await mermaid.render(`${inlinksDiv.id}-svg`, inlinkMermaidStr);
          inlinksDiv.insertAdjacentHTML("beforeend", svg);
          inlinksDiv.children[0].addClass("zk-full-width");
          inlinksDiv.children[0].setAttribute("height", `${this.graphHeight}px`);
          graphMermaidDiv.appendChild(inlinksDiv);
          let panZoomTiger = svgPanZoom(`#${inlinksDiv.id}-svg`, {
            zoomEnabled: true,
            controlIconsEnabled: false,
            fit: false,
            center: true,
            minZoom: 1e-3,
            maxZoom: 1e3,
            dblClickZoomEnabled: false,
            zoomScaleSensitivity: 0.3
          });
          let setSvg = document.getElementById(`${inlinksDiv.id}-svg`);
          if (setSvg !== null) {
            let a = setSvg.children[0].getAttr("style");
            if (typeof a == "string") {
              let b = a.match(/\d([^\,]+)\d/g);
              if (b !== null && Number(b[0]) > 1) {
                panZoomTiger.zoom(1 / Number(b[0]));
              }
            }
          }
          let nodeGArr = inlinksDiv.querySelectorAll("[id^='flowchart-']");
          let nodeArr = inlinksDiv.getElementsByClassName("nodeLabel");
          inlinkArr.push(this.currentFile);
          for (let i = 0; i < nodeArr.length; i++) {
            let link = document.createElement("a");
            link.addClass("internal-link");
            let nodePosStr = nodeGArr[i].id.split("-")[1];
            let node = inlinkArr[Number(nodePosStr)];
            link.textContent = nodeArr[i].getText();
            nodeArr[i].textContent = "";
            nodeArr[i].appendChild(link);
            nodeGArr[i].addEventListener("click", (event) => {
              if (event.ctrlKey) {
                this.app.workspace.openLinkText("", node.path, "tab");
              } else if (event.shiftKey) {
                this.plugin.retrivalforLocaLgraph = {
                  type: "1",
                  ID: "",
                  filePath: node.path
                };
                this.plugin.openGraphView();
              } else if (event.altKey) {
                if (this.plugin.settings.FolderOfIndexes !== "" && node.path.startsWith(this.plugin.settings.FolderOfIndexes)) {
                  this.plugin.clearShowingSettings();
                  this.plugin.settings.lastRetrival = {
                    type: "index",
                    ID: "",
                    displayText: "",
                    filePath: node.path,
                    openTime: ""
                  };
                  this.plugin.RefreshIndexViewFlag = true;
                  this.plugin.openIndexView();
                } else {
                  let mainNote = this.plugin.MainNotes.find((n) => n.file.path == node.path);
                  if (mainNote) {
                    this.plugin.clearShowingSettings();
                    this.plugin.settings.lastRetrival = {
                      type: "main",
                      ID: mainNote.ID,
                      displayText: mainNote.displayText,
                      filePath: mainNote.file.path,
                      openTime: ""
                    };
                    this.plugin.RefreshIndexViewFlag = true;
                    this.plugin.openIndexView();
                  }
                }
              } else {
                this.app.workspace.openLinkText("", node.path);
              }
            });
            nodeGArr[i].addEventListener("touchend", () => {
              this.app.workspace.openLinkText("", node.path);
            });
            nodeGArr[i].addEventListener(`mouseover`, (event) => {
              this.app.workspace.trigger(`hover-link`, {
                event,
                source: ZK_NAVIGATION,
                hoverParent: this,
                linktext: "",
                targetEl: link,
                sourcePath: node.path
              });
            });
          }
        }
        if (this.plugin.settings.OutlinksGraphToggle == true) {
          let outlinkArr = [];
          if (this.currentFile.extension === "md") {
            outlinkArr = await this.getOutlinks(this.currentFile);
          }
          let outlinkMermaidStr = await this.genericLinksMermaidStr(this.currentFile, outlinkArr, "out", this.plugin.settings.DirectionOfOutlinksGraph);
          const outlinksGraphContainer = graphMermaidDiv.createDiv("zk-outlinks-graph-container");
          const outlinksGraphTextDiv = outlinksGraphContainer.createDiv("zk-graph-text");
          outlinksGraphTextDiv.empty();
          outlinksGraphTextDiv.createEl("span", { text: t("outlinks") });
          let graphIconDiv = outlinksGraphContainer.createDiv("zk-graph-icon");
          graphIconDiv.empty();
          let expandBtn = new import_obsidian14.ExtraButtonComponent(graphIconDiv);
          expandBtn.setIcon("expand").setTooltip(t("expand graph"));
          expandBtn.onClick(() => {
            new expandGraphModal(this.app, this.plugin, [], outlinkArr, outlinkMermaidStr).open();
          });
          const outlinksDiv = outlinksGraphContainer.createEl("div", { cls: "zk-graph-mermaid" });
          outlinksDiv.id = "zk-outlinks";
          let { svg } = await mermaid.render(`${outlinksDiv.id}-svg`, outlinkMermaidStr);
          outlinksDiv.insertAdjacentHTML("beforeend", svg);
          outlinksDiv.children[0].addClass("zk-full-width");
          outlinksDiv.children[0].setAttribute("height", `${this.graphHeight}px`);
          graphMermaidDiv.appendChild(outlinksDiv);
          let panZoomTiger = svgPanZoom(`#${outlinksDiv.id}-svg`, {
            zoomEnabled: true,
            controlIconsEnabled: false,
            fit: false,
            center: true,
            minZoom: 1e-3,
            maxZoom: 1e3,
            dblClickZoomEnabled: false,
            zoomScaleSensitivity: 0.3
          });
          let setSvg = document.getElementById(`${outlinksDiv.id}-svg`);
          if (setSvg !== null) {
            let a = setSvg.children[0].getAttr("style");
            if (typeof a == "string") {
              let b = a.match(/\d([^\,]+)\d/g);
              if (b !== null && Number(b[0]) > 1) {
                panZoomTiger.zoom(1 / Number(b[0]));
              }
            }
          }
          let nodeGArr = outlinksDiv.querySelectorAll("[id^='flowchart-']");
          let nodeArr = outlinksDiv.getElementsByClassName("nodeLabel");
          outlinkArr.push(this.currentFile);
          for (let i = 0; i < nodeArr.length; i++) {
            let link = document.createElement("a");
            link.addClass("internal-link");
            let nodePosStr = nodeGArr[i].id.split("-")[1];
            let node = outlinkArr[Number(nodePosStr)];
            link.textContent = nodeArr[i].getText();
            nodeArr[i].textContent = "";
            nodeArr[i].appendChild(link);
            nodeGArr[i].addEventListener("click", async (event) => {
              if (event.ctrlKey) {
                this.app.workspace.openLinkText("", node.path, "tab");
              } else if (event.shiftKey) {
                this.plugin.retrivalforLocaLgraph = {
                  type: "1",
                  ID: "",
                  filePath: node.path
                };
                this.plugin.openGraphView();
              } else if (event.altKey) {
                if (this.plugin.settings.FolderOfIndexes !== "" && node.path.startsWith(this.plugin.settings.FolderOfIndexes)) {
                  this.plugin.clearShowingSettings();
                  this.plugin.settings.lastRetrival = {
                    type: "index",
                    ID: "",
                    displayText: "",
                    filePath: node.path,
                    openTime: ""
                  };
                  this.plugin.RefreshIndexViewFlag = true;
                  this.plugin.openIndexView();
                } else {
                  let mainNote = this.plugin.MainNotes.find((n) => n.file.path == node.path);
                  if (mainNote) {
                    this.plugin.clearShowingSettings();
                    this.plugin.settings.lastRetrival = {
                      type: "main",
                      ID: mainNote.ID,
                      displayText: mainNote.displayText,
                      filePath: mainNote.file.path,
                      openTime: ""
                    };
                    this.plugin.RefreshIndexViewFlag = true;
                    this.plugin.openIndexView();
                  }
                }
              } else {
                this.app.workspace.openLinkText("", node.path);
              }
            });
            nodeGArr[i].addEventListener("touchend", () => {
              this.app.workspace.openLinkText("", node.path);
            });
            nodeGArr[i].addEventListener(`mouseover`, (event) => {
              this.app.workspace.trigger(`hover-link`, {
                event,
                source: ZK_NAVIGATION,
                hoverParent: this,
                linktext: "",
                targetEl: link,
                sourcePath: node.path
              });
            });
          }
        }
      }
    };
    this.plugin = plugin;
  }
  getViewType() {
    return ZK_GRAPH_TYPE;
  }
  getDisplayText() {
    return ZK_GRAPH_VIEW;
  }
  getIcon() {
    return "network";
  }
  onResize() {
    if (this.app.workspace.getLeavesOfType(ZK_GRAPH_TYPE).length > 0) {
      this.app.workspace.trigger("zk-navigation:refresh-local-graph");
    }
  }
  async onOpen() {
    this.refreshLocalGraph();
  }
  onload() {
    const refresh = (0, import_obsidian14.debounce)(this.refreshLocalGraph, 300, true);
    this.registerEvent(this.app.vault.on("rename", () => {
      refresh();
    }));
    this.registerEvent(this.app.vault.on("create", () => {
      refresh();
    }));
    this.registerEvent(this.app.vault.on("delete", () => {
      refresh();
    }));
    this.registerEvent(this.app.metadataCache.on("changed", () => {
      refresh();
    }));
    this.registerEvent(this.app.metadataCache.on("deleted", () => {
      refresh();
    }));
    this.registerEvent(this.app.workspace.on("active-leaf-change", async (leaf) => {
      if (this.app.workspace.getLeavesOfType(ZK_GRAPH_TYPE).length > 0) {
        if (this.app.workspace.getActiveViewOfType(import_obsidian14.FileView)) {
          this.plugin.retrivalforLocaLgraph.type = "2";
          refresh();
        }
      }
    }));
    this.registerEvent(this.app.workspace.on("zk-navigation:refresh-local-graph", refresh));
  }
  async getFamilyNodes(currentFile) {
    this.familyNodeArr = [];
    let Nodes = this.plugin.MainNotes.filter((n) => n.file == currentFile);
    if (Nodes.length > 0) {
      if (this.plugin.retrivalforLocaLgraph.ID !== "") {
        Nodes = Nodes.filter((n) => n.ID == this.plugin.retrivalforLocaLgraph.ID);
      } else {
        this.plugin.retrivalforLocaLgraph.ID = Nodes[0].ID;
      }
    }
    if (Nodes.length > 0) {
      let currentNode = Nodes[0];
      if (currentNode.IDArr.length > 1) {
        let fatherArr = currentNode.IDArr.slice(0, currentNode.IDArr.length - 1);
        let fatherNode = this.plugin.MainNotes.filter((n) => n.IDStr == fatherArr.toString());
        if (fatherNode.length > 0) {
          this.familyNodeArr = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(fatherNode[0].IDStr)).filter((n) => n.IDArr.length <= currentNode.IDArr.length || n.IDStr.startsWith(currentNode.IDStr) && n.IDArr.length == currentNode.IDArr.length + 1);
        } else {
          this.familyNodeArr = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(currentNode.IDStr) && n.IDArr.length <= currentNode.IDArr.length + 1);
        }
      } else {
        this.familyNodeArr = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(currentNode.IDStr) && n.IDArr.length <= currentNode.IDArr.length + 1);
      }
    }
    if (this.plugin.settings.siblingLenToggle === true) {
      const maxLength = Math.max(...this.familyNodeArr.map((n) => n.IDArr.length));
      const minLength = Math.min(...this.familyNodeArr.map((n) => n.IDArr.length));
      for (let i = minLength; i <= maxLength; i++) {
        let layerNodes = this.familyNodeArr.filter((n) => n.IDArr.length === i);
        if (layerNodes.length > 1) {
          let maxTextLen = Math.max(...layerNodes.map((n) => displayWidth(n.displayText)));
          for (let node of layerNodes) {
            node.fixWidth = 6 * maxTextLen + 6;
          }
        } else {
          layerNodes[0].fixWidth = 0;
        }
      }
    }
  }
  async getInlinks(currentFile) {
    let inlinkArr = [];
    const resolvedLinks = this.app.metadataCache.resolvedLinks;
    for (let src of Object.keys(resolvedLinks)) {
      let link = resolvedLinks[src];
      for (let dest of Object.keys(link)) {
        if (dest === currentFile.path) {
          let inlinkFile = this.app.vault.getFileByPath(src);
          if (inlinkFile !== null) {
            inlinkArr.push(inlinkFile);
          }
        }
      }
    }
    return inlinkArr;
  }
  async getOutlinks(currentFile) {
    let outlinkArr = [];
    const resolvedLinks = this.app.metadataCache.resolvedLinks;
    let outlinks = Object.keys(resolvedLinks[currentFile.path]);
    if (this.plugin.settings.FileExtension == "md") {
      outlinks = outlinks.filter((link) => link.endsWith(".md"));
    }
    for (let outlink of outlinks) {
      let outlinkFile = this.app.vault.getFileByPath(outlink);
      if (outlinkFile !== null) {
        outlinkArr.push(outlinkFile);
      }
    }
    return outlinkArr;
  }
  async genericLinksMermaidStr(currentFile, linkArr, direction1 = "in", direction2) {
    let mermaidStr = `%%{ init: { 'flowchart': { 'curve': 'basis', 'wrappingWidth': '3000' },
        'themeVariables':{ 'fontSize': '12px'}}}%% flowchart ${direction2};
`;
    let currentNode = [];
    if (this.familyNodeArr.length > 0) {
      currentNode = this.familyNodeArr.filter((n) => n.file == currentFile);
      if (currentNode.length == 0) {
        currentNode = this.plugin.MainNotes.filter((n) => n.file === currentFile);
      }
    }
    if (currentNode.length > 0) {
      mermaidStr = mermaidStr + `${linkArr.length}("${currentNode[0].displayText}");
            style ${linkArr.length} fill:${this.plugin.settings.nodeColor},stroke:#333,stroke-width:1px 
`;
    } else {
      mermaidStr = mermaidStr + `${linkArr.length}("${currentFile.basename}");
            style ${linkArr.length} fill:${this.plugin.settings.nodeColor},stroke:#333,stroke-width:1px 
`;
    }
    for (let i = 0; i < linkArr.length; i++) {
      let node = this.plugin.MainNotes.find((n) => n.file == linkArr[i]);
      if (typeof node !== "undefined") {
        mermaidStr = mermaidStr + `${i}("${node.displayText}");
`;
      } else {
        mermaidStr = mermaidStr + `${i}("${linkArr[i].basename}");
`;
      }
      mermaidStr = mermaidStr + `style ${i} fill:#fff; 
`;
      if (direction1 == "in") {
        mermaidStr = mermaidStr + `${i} --> ${linkArr.length};
`;
      } else {
        mermaidStr = mermaidStr + `${linkArr.length} --> ${i};
`;
      }
    }
    return mermaidStr;
  }
  async genericFamilyMermaidStr(currentFile, direction) {
    let mermaidStr = `%%{ init: { 'flowchart': { 'curve': 'basis', 'wrappingWidth': '3000' },
        'themeVariables':{ 'fontSize': '12px'}}}%% flowchart ${direction};`;
    for (let node of this.familyNodeArr) {
      if (this.plugin.settings.siblingLenToggle === true && node.fixWidth !== 0) {
        mermaidStr = mermaidStr + `${node.position}("<p style='width:${node.fixWidth}px;margin:0px;'>${node.displayText}</p>");
`;
      } else {
        mermaidStr = mermaidStr + `${node.position}("${node.displayText}");
`;
      }
      if (node.file == currentFile) {
        mermaidStr = mermaidStr + `style ${node.position} fill:${this.plugin.settings.nodeColor},stroke:#333,stroke-width:1px 
`;
      } else {
        mermaidStr = mermaidStr + `style ${node.position} fill:#fff; 
`;
      }
    }
    for (let node of this.familyNodeArr) {
      let sonNodes = this.familyNodeArr.filter((n) => n.IDArr.length - 1 == node.IDArr.length && n.IDStr.startsWith(node.IDStr) && n.ID.startsWith(node.ID));
      for (let son of sonNodes) {
        mermaidStr = mermaidStr + `${node.position} --> ${son.position};
`;
      }
    }
    if (this.plugin.settings.RedDashLine === true) {
      for (let node of this.familyNodeArr) {
        if (/^[a-zA-Z]$/.test(node.file.basename.slice(-1))) {
          mermaidStr = mermaidStr + `style ${node.position} stroke:#f66,stroke-width:2px,stroke-dasharray: 1 
`;
        }
      }
    }
    return mermaidStr;
  }
  async genericGitgraphStr(currentFile) {
    this.generateGitBranch();
    this.order = 0;
    this.result = [];
    let temBranches = this.gitBranches.filter((b) => b.branchName === "main");
    this.gitBranches = this.gitBranches.filter((b) => b.branchName !== "main");
    if (temBranches.length > 0) {
      this.orderGitBranch(temBranches[0]);
    }
    temBranches = this.result.filter((b) => b.branchName === "main");
    this.gitBranches = this.result.filter((b) => b.branchName !== "main");
    let gitNodePos = 0;
    let gitStr = "";
    while (temBranches.length > 0) {
      let nextBranch = temBranches.reduce((min, obj) => {
        return min && min.nodes[min.currentPos].ctime < obj.nodes[obj.currentPos].ctime ? min : obj;
      }, temBranches[0]);
      let branchIndex = temBranches.indexOf(nextBranch);
      let nextNode = temBranches[branchIndex].nodes[temBranches[branchIndex].currentPos];
      temBranches[branchIndex].currentPos = temBranches[branchIndex].currentPos + 1;
      nextNode.gitNodePos = gitNodePos;
      gitNodePos = gitNodePos + 1;
      if (nextBranch.active === false) {
        gitStr = gitStr + `checkout ${nextBranch.branchPoint.branchName}
`;
        nextBranch.active = true;
      }
      gitStr = gitStr + `checkout ${nextBranch.branchName}
            commit id: "${nextNode == null ? void 0 : nextNode.displayText}"`;
      if ((nextNode == null ? void 0 : nextNode.ID) === this.plugin.retrivalforLocaLgraph.ID) {
        gitStr = gitStr + `tag: "index\u{1F33F}"`;
      }
      gitStr = gitStr + `
`;
      if (temBranches[branchIndex].nodes.length === temBranches[branchIndex].currentPos) {
        temBranches.splice(branchIndex, 1);
      }
      let newBranches = this.gitBranches.filter((n) => n.branchPoint.ID == (nextNode == null ? void 0 : nextNode.ID));
      for (let branch of newBranches) {
        temBranches.push(branch);
        gitStr = gitStr + `branch ${branch.branchName} order: ${branch.order}
`;
      }
    }
    let mermaidStr = `%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': false, 'parallelCommits': true, 'rotateCommitLabel': true}} }%%
                                gitGraph
                                ${gitStr}
                                `;
    return mermaidStr;
  }
  generateGitBranch() {
    let Nodes = this.familyNodeArr;
    const maxLength = Math.max(...Nodes.map((n) => n.IDArr.length));
    const minLength = Math.min(...Nodes.map((n) => n.IDArr.length));
    this.gitBranches = [];
    let nodes = Nodes.filter((l) => l.IDArr.length === minLength);
    this.gitBranches.push({
      branchName: "main",
      branchPoint: Nodes[0],
      nodes,
      currentPos: 0,
      order: 0,
      positionX: 0,
      active: true
    });
    let nodeIndex = Nodes.indexOf(nodes[0]);
    Nodes[nodeIndex].branchName = "main";
    for (let i = minLength; i < maxLength; i++) {
      let layerNodes = Nodes.filter((n) => n.IDArr.length === i);
      for (let fatherNode of layerNodes) {
        let numberSons = Nodes.filter((n) => n.IDArr.length === i + 1 && /[0-9]/.test(n.ID.slice(-1)) && n.IDArr.slice(0, -1).toString() === fatherNode.IDStr);
        if (numberSons.length > 0) {
          let branchName = `B${this.gitBranches.length}`;
          let gitBranch = {
            branchName,
            branchPoint: fatherNode,
            nodes: numberSons,
            currentPos: 0,
            positionX: 0,
            order: 0,
            active: false
          };
          this.gitBranches.push(gitBranch);
          for (let node of numberSons) {
            let index = Nodes.indexOf(node);
            Nodes[index].branchName = branchName;
          }
        }
        let letterSons = Nodes.filter((n) => n.IDArr.length === i + 1 && /[a-zA-Z]/.test(n.ID.slice(-1)) && n.IDArr.slice(0, -1).toString() === fatherNode.IDStr);
        if (letterSons.length > 0) {
          let branchName = `B${this.gitBranches.length}`;
          let gitBranch = {
            branchName,
            branchPoint: fatherNode,
            nodes: letterSons,
            currentPos: 0,
            order: 0,
            positionX: 0,
            active: false
          };
          this.gitBranches.push(gitBranch);
          for (let node of letterSons) {
            let index = Nodes.indexOf(node);
            Nodes[index].branchName = branchName;
          }
        }
      }
    }
  }
  orderGitBranch(current) {
    current.order = this.order;
    this.result.push(current);
    this.order = this.order + 1;
    for (let i = current.nodes.length - 1; i >= 0; i--) {
      let branches = this.gitBranches.filter((b) => b.branchPoint.ID === current.nodes[i].ID);
      if (branches.length > 0) {
        branches.sort((a, b) => a.nodes[0].ctime - b.nodes[0].ctime);
        for (let next of branches) {
          this.orderGitBranch(next);
        }
      }
    }
  }
  countGraphs() {
    let count = 0;
    if (this.plugin.settings.FamilyGraphToggle === true) {
      count++;
    }
    if (this.plugin.settings.InlinksGraphToggle === true) {
      count++;
    }
    if (this.plugin.settings.OutlinksGraphToggle === true) {
      count++;
    }
    this.countOfGraphs = count;
  }
  async onClose() {
  }
};

// src/view/outlineView.ts
var import_obsidian15 = require("obsidian");
var ZK_OUTLINE_TYPE = "zk-outline-type";
var ZK_OUTLINE_VIEW = t("list tree");
var ZKOutlineView = class extends import_obsidian15.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.maxLength = 0;
    this.minLength = 0;
    this.refreshOutlineView = async () => {
      let { containerEl } = this;
      containerEl.empty();
      const headerDiv = containerEl.createDiv("nav-header").createDiv("nav-buttons-container");
      this.plugin.tableArr.sort((a, b) => a.IDStr.localeCompare(b.IDStr));
      this.maxLength = Math.max(...this.plugin.tableArr.map((n) => n.IDArr.length));
      this.minLength = Math.min(...this.plugin.tableArr.map((n) => n.IDArr.length));
      this.defautLength = this.plugin.settings.outlineLayer;
      const slider = new import_obsidian15.SliderComponent(headerDiv);
      let maxLayer = this.maxLength - this.minLength + 1;
      if (this.defautLength > maxLayer) {
        this.defautLength = maxLayer;
      }
      slider.setLimits(1, maxLayer, 1).setDynamicTooltip().setValue(this.defautLength).onChange((value) => {
        this.plugin.settings.outlineLayer = value;
        this.plugin.saveData(this.plugin.settings);
        this.app.workspace.trigger("zk-navigation:refresh-outline-view");
      });
      const outlineViewDiv = this.containerEl.createDiv("view-content node-insert-event");
      outlineViewDiv.id = "view-content";
      await this.createListTree(this.plugin.tableArr[0], outlineViewDiv);
    };
    this.plugin = plugin;
  }
  getViewType() {
    return ZK_OUTLINE_TYPE;
  }
  getDisplayText() {
    return ZK_OUTLINE_VIEW;
  }
  getIcon() {
    return "list-tree";
  }
  onload() {
    const refresh = (0, import_obsidian15.debounce)(this.refreshOutlineView, 300, true);
    this.registerEvent(this.app.workspace.on("zk-navigation:refresh-outline-view", refresh));
  }
  async onOpen() {
    this.refreshOutlineView();
  }
  async createListTree(item, itemEl) {
    let children = this.plugin.tableArr.filter((n) => n.IDArr.length === item.IDArr.length + 1 && n.IDStr.startsWith(item.IDStr));
    let treeItem = itemEl.createDiv("tree-item");
    let treeItemSelf = treeItem.createDiv("tree-item-self is-clickable");
    treeItemSelf.addEventListener(`mouseover`, (event) => {
      this.app.workspace.trigger(`hover-link`, {
        event,
        source: ZK_NAVIGATION,
        hoverParent: this,
        linktext: "",
        targetEl: treeItemSelf,
        sourcePath: item.file.path
      });
    });
    treeItemSelf.addEventListener("click", async (event) => {
      if (event.ctrlKey) {
        navigator.clipboard.writeText(item.ID);
        new import_obsidian15.Notice(item.ID + " copied");
      } else if (event.shiftKey) {
        this.plugin.settings.lastRetrival = {
          type: "main",
          ID: item.ID,
          displayText: item.displayText,
          filePath: item.file.path,
          openTime: ""
        };
        await this.plugin.clearShowingSettings();
        this.plugin.RefreshIndexViewFlag = true;
        this.plugin.openIndexView();
      } else if (event.altKey) {
        this.plugin.retrivalforLocaLgraph = {
          type: "1",
          ID: item.ID,
          filePath: item.file.path
        };
        this.plugin.openGraphView();
      } else {
        this.app.workspace.openLinkText("", item.file.path);
      }
    });
    const treeItemChildren = treeItem.createDiv("tree-item-children");
    let treeIteminner = treeItemSelf.createDiv("tree-item-inner");
    treeIteminner.setText(`${item.displayText}`);
    if (children.length > 0) {
      let treeItemIcon = treeItemSelf.createDiv("tree-item-icon collapse-icon");
      let icon = new import_obsidian15.ExtraButtonComponent(treeItemIcon);
      icon.setIcon("right-triangle");
      treeItemIcon.addEventListener("click", (event) => {
        if (treeItemIcon.hasClass("is-collapsed")) {
          treeItemIcon.removeClass("is-collapsed");
          treeItemChildren.removeClass("zk-hidden");
        } else {
          treeItemIcon.addClass("is-collapsed");
          treeItemChildren.addClass("zk-hidden");
        }
        event.stopPropagation();
      });
      if (item.IDArr.length - this.minLength + 1 >= this.defautLength) {
        treeItemIcon.addClass("is-collapsed");
        treeItemChildren.addClass("zk-hidden");
      }
      for (let i = 0; i < children.length; i++) {
        await this.createListTree(children[i], treeItemChildren);
      }
    }
  }
};

// src/view/recentView.ts
var import_obsidian16 = require("obsidian");
var ZK_RECENT_TYPE = "zk-recent-type";
var ZK_RECENT_VIEW = t("History List");
var ZKRecentView = class extends import_obsidian16.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.refreshRecentView = async () => {
      let { containerEl } = this;
      containerEl.empty();
      const historyListDiv = this.containerEl.createDiv("view-content node-insert-event");
      for (let i = 0; i < this.plugin.settings.HistoryList.length; i++) {
        let item = this.plugin.settings.HistoryList[i];
        let line = historyListDiv.createEl("div", { text: `${i + 1}. ${item.displayText}`, cls: "vertical-tab-nav-item recent-item" });
        line.addEventListener(`mousemove`, (event) => {
          this.app.workspace.trigger(`hover-link`, {
            event,
            source: ZK_NAVIGATION,
            hoverParent: line,
            linktext: "",
            targetEl: line,
            sourcePath: item.filePath
          });
        });
        line.addEventListener("click", async () => {
          this.plugin.settings.lastRetrival = item;
          this.plugin.settings.lastRetrival.openTime = (0, import_obsidian16.moment)().format("YYYY-MM-DD HH:mm:ss");
          this.plugin.settings.HistoryList.splice(i, 1);
          this.plugin.settings.HistoryList.unshift(this.plugin.settings.lastRetrival);
          this.plugin.settings.zoomPanScaleArr = [];
          this.plugin.settings.BranchTab = 0;
          this.plugin.settings.FoldNodeArr = [];
          this.app.workspace.trigger("zk-navigation:refresh-recent-view");
          this.plugin.RefreshIndexViewFlag = true;
          this.plugin.openIndexView();
        });
        const closeBtnDiv = line.createDiv("recent-close-button zk-hidden");
        const closeBtn = new import_obsidian16.ExtraButtonComponent(closeBtnDiv);
        closeBtn.setIcon("x");
        closeBtnDiv.addEventListener("click", (event) => {
          this.plugin.settings.HistoryList.splice(i, 1);
          this.app.workspace.trigger("zk-navigation:refresh-recent-view");
          event.stopPropagation();
        });
        line.addEventListener("mouseenter", function() {
          closeBtnDiv.removeClass("zk-hidden");
        });
        line.addEventListener("mouseleave", function() {
          closeBtnDiv.addClass("zk-hidden");
        });
      }
    };
    this.plugin = plugin;
  }
  getViewType() {
    return ZK_RECENT_TYPE;
  }
  getDisplayText() {
    return ZK_RECENT_VIEW;
  }
  getIcon() {
    return "history";
  }
  onload() {
    const refresh = (0, import_obsidian16.debounce)(this.refreshRecentView, 300, true);
    this.registerEvent(this.app.workspace.on("zk-navigation:refresh-recent-view", refresh));
  }
  async onOpen() {
    this.refreshRecentView();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  FolderOfMainNotes: "",
  FolderOfIndexes: "",
  StartingPoint: "parent",
  DisplayLevel: "end",
  NodeText: "both",
  FamilyGraphToggle: true,
  InlinksGraphToggle: true,
  OutlinksGraphToggle: true,
  TagOfMainNotes: "",
  IDFieldOption: "1",
  TitleField: "",
  IDField: "",
  Separator: " ",
  IndexButtonText: t("\u{1F4D6}index"),
  SuggestMode: "fuzzySuggest",
  FoldToggle: false,
  FoldNodeArr: [],
  RedDashLine: false,
  zoomPanScaleArr: [],
  CustomCreatedTime: "",
  BranchTab: 0,
  FileExtension: "md",
  SectionTab: 0,
  DirectionOfBranchGraph: "LR",
  DirectionOfFamilyGraph: "LR",
  DirectionOfInlinksGraph: "TB",
  DirectionOfOutlinksGraph: "TB",
  BranchToolbra: true,
  RandomIndex: true,
  RandomMainNote: true,
  TableView: true,
  IndexButton: false,
  MainNoteButton: true,
  MainNoteButtonText: t("Main notes"),
  settingIcon: true,
  MainNoteSuggestMode: "fuzzySuggest",
  ListTree: true,
  HistoryList: [],
  HistoryToggle: true,
  HistoryMaxCount: 20,
  exportCanvas: true,
  cardWidth: 400,
  cardHeight: 240,
  canvasFilePath: "",
  siblingsOrder: "number",
  showAll: false,
  showAllToggle: true,
  outlineLayer: 2,
  maxLenMainModel: 100,
  maxLenIndexModel: 100,
  multiIDToggle: false,
  multiIDField: "",
  lastRetrival: { type: "", ID: "", displayText: "", filePath: "", openTime: "" },
  NodeCommands: [],
  siblingLenToggle: false,
  displayTimeToggle: false,
  playControllerToggle: true,
  nodeColor: "#FFFFAA",
  datetimeFormat: "yyyy-MM-DD HH:mm",
  graphType: "structure",
  nodeClose: false,
  gitUncrossing: false
};
var ZKNavigationPlugin = class extends import_obsidian17.Plugin {
  constructor() {
    super(...arguments);
    this.MainNotes = [];
    this.tableArr = [];
    this.retrivalforLocaLgraph = {
      type: "2",
      ID: "",
      filePath: ""
    };
    this.indexViewOffsetWidth = 0;
    this.indexViewOffsetHeight = 0;
    this.RefreshIndexViewFlag = false;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async onload() {
    await this.loadSettings();
    this.registerObsidianProtocolHandler("zk-navigation", async (para) => {
      if (para.file) {
        let file = this.app.vault.getFileByPath(para.file);
        if (!file) {
          new import_obsidian17.Notice(`zk-navigation: file "${para.file}" can't be found!`);
          return;
        }
        if (para.from && ["root", "parent", "index"].includes(para.from)) {
          this.settings.StartingPoint = para.from;
        }
        if (para.to && ["next", "end"].includes(para.to)) {
          this.settings.DisplayLevel = para.to;
        }
        if (para.text && ["id", "title", "both"].includes(para.text)) {
          this.settings.NodeText = para.text;
        }
        if (para.type && ["structure", "roadmap"].includes(para.type)) {
          this.settings.graphType = para.type;
        }
        let indexFlag = false;
        if (this.settings.FolderOfIndexes !== "") {
          if (para.file.startsWith(this.settings.FolderOfIndexes)) {
            indexFlag = true;
            this.settings.lastRetrival = {
              type: "index",
              ID: "",
              displayText: "",
              filePath: file.path,
              openTime: ""
            };
            this.settings.zoomPanScaleArr = [];
            this.settings.BranchTab = 0;
            this.settings.FoldNodeArr = [];
            this.RefreshIndexViewFlag = true;
            await this.openIndexView();
          }
        }
        if (!indexFlag) {
          this.settings.lastRetrival = {
            type: "main",
            ID: "",
            displayText: "",
            filePath: file.path,
            openTime: ""
          };
          this.settings.zoomPanScaleArr = [];
          this.settings.BranchTab = 0;
          this.settings.FoldNodeArr = [];
          this.RefreshIndexViewFlag = true;
          await this.openIndexView();
        }
      } else {
        new import_obsidian17.Notice(`zk-navigation: invalid uri`);
      }
    });
    this.registerEvent(this.app.workspace.on("file-menu", (menu, file, source) => {
      if (!(source === "more-options" || source === "tab-header" || source == "file-explorer-context-menu")) {
        return;
      }
      if (!(file instanceof import_obsidian17.TFile)) {
        return;
      }
      menu.addItem((item) => {
        item.setTitle(t("Copy zk-navigation URI")).setIcon("copy").setSection("info").onClick(() => navigator.clipboard.writeText(`obsidian://zk-navigation?file=${encodeURI(file.path)}`));
      });
    }));
    this.addSettingTab(new ZKNavigationSettngTab(this.app, this));
    this.registerView(ZK_INDEX_TYPE, (leaf) => new ZKIndexView(leaf, this));
    this.registerView(ZK_GRAPH_TYPE, (leaf) => new ZKGraphView(leaf, this));
    this.registerView(ZK_OUTLINE_TYPE, (leaf) => new ZKOutlineView(leaf, this));
    this.registerView(ZK_RECENT_TYPE, (leaf) => new ZKRecentView(leaf, this));
    this.addRibbonIcon("ghost", t("open zk-index-graph"), async () => {
      this.openIndexView();
    });
    this.addRibbonIcon("network", t("open zk-local-graph"), async () => {
      this.openGraphView();
    });
    this.addCommand({
      id: "zk-index-graph",
      name: t("open zk-index-graph"),
      callback: async () => {
        this.openIndexView();
      }
    });
    this.addCommand({
      id: "zk-local-graph",
      name: t("open zk-local-graph"),
      callback: async () => {
        this.openGraphView();
      }
    });
    this.addCommand({
      id: "zk-index-graph-by-file",
      name: t("reveal current file in zk-index-graph"),
      callback: async () => {
        await this.revealFileInIndexView();
      }
    });
    this.registerHoverLinkSource(ZK_NAVIGATION, {
      defaultMod: true,
      display: ZK_NAVIGATION
    });
  }
  async openIndexView() {
    var _a;
    if (this.app.workspace.getLeavesOfType(ZK_INDEX_TYPE).length === 0) {
      await ((_a = this.app.workspace.getLeaf("tab")) == null ? void 0 : _a.setViewState({
        type: ZK_INDEX_TYPE,
        active: true
      }));
    }
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(ZK_INDEX_TYPE)[0]);
    if (this.RefreshIndexViewFlag === true) {
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
    }
  }
  async openGraphView() {
    var _a;
    if (this.app.workspace.getLeavesOfType(ZK_GRAPH_TYPE).length === 0) {
      await ((_a = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a.setViewState({
        type: ZK_GRAPH_TYPE,
        active: true
      }));
    }
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(ZK_GRAPH_TYPE)[0]);
    this.app.workspace.trigger("zk-navigation:refresh-local-graph");
  }
  async openOutlineView() {
    var _a;
    if (this.app.workspace.getLeavesOfType(ZK_OUTLINE_TYPE).length === 0) {
      await ((_a = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a.setViewState({
        type: ZK_OUTLINE_TYPE,
        active: true
      }));
    }
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(ZK_OUTLINE_TYPE)[0]);
    await this.app.workspace.trigger("zk-navigation:refresh-outline-view");
  }
  async openRecentView() {
    var _a;
    if (this.app.workspace.getLeavesOfType(ZK_RECENT_TYPE).length === 0) {
      await ((_a = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a.setViewState({
        type: ZK_RECENT_TYPE,
        active: true
      }));
    }
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(ZK_RECENT_TYPE)[0]);
    this.app.workspace.trigger("zk-navigation:refresh-recent-view");
  }
  async clearShowingSettings(BranchTab = 0) {
    this.settings.zoomPanScaleArr = [];
    this.settings.BranchTab = BranchTab;
    this.settings.FoldNodeArr = [];
  }
  async revealFileInIndexView() {
    var _a, _b;
    let filePath = (_b = (_a = this.app.workspace.getActiveViewOfType(import_obsidian17.FileView)) == null ? void 0 : _a.file) == null ? void 0 : _b.path;
    if (filePath && filePath.endsWith(".md")) {
      let indexFlag = false;
      if (this.settings.FolderOfIndexes !== "") {
        if (filePath.startsWith(this.settings.FolderOfIndexes)) {
          indexFlag = true;
          this.settings.lastRetrival = {
            type: "index",
            ID: "",
            displayText: "",
            filePath,
            openTime: ""
          };
          this.clearShowingSettings();
          this.RefreshIndexViewFlag = true;
          await this.openIndexView();
        }
      }
      if (!indexFlag) {
        await mainNoteInit(this);
        this.settings.lastRetrival = {
          type: "main",
          ID: "",
          displayText: "",
          filePath,
          openTime: ""
        };
        this.clearShowingSettings();
        this.RefreshIndexViewFlag = true;
        await this.openIndexView();
      }
      return;
    }
  }
  onunload() {
    this.saveData(this.settings);
  }
};

/* nosourcemap */